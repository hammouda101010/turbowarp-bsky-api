// This is The New OAuth Rewrite. It may be unstable
// Required Modules
import {
  BrowserOAuthClient,
  OAuthClientMetadataInput,
  OAuthSession
} from "@atproto/oauth-client-browser"
import { AppBskyGraphDefs, Agent } from "@atproto/api"
// import { moderatePost } from "@atproto/api"
import { RichText } from "@atproto/api"
import { AtUri } from "@atproto/api"
import { Mime } from "mime"
;(function (Scratch) {
  if (Scratch.extensions.unsandboxed === false) {
    throw new Error("TurboButterfly Extension Must Be Run Unsandboxed.")
  }
  // The extension's code
  // Scratch's Stuff
  const vm = Scratch.vm
  const runtime = vm.runtime
  const Cast = Scratch.Cast

  const exId = "HamBskyAPI"

  // Allows Square Blocks for TW (Credits to SharkPool)
  //@ts-expect-error included in runtime
  const ogConverter = runtime._convertBlockForScratchBlocks.bind(runtime)
  //@ts-expect-error included in runtime
  runtime._convertBlockForScratchBlocks = function (blockInfo, categoryInfo) {
    const res = ogConverter(blockInfo, categoryInfo)
    if (blockInfo.outputShape) res.json.outputShape = blockInfo.outputShape
    return res
  }

  // Events
  const BskyLoginEvent = new CustomEvent("bskyLogin")
  const BskyLogoutEvent = new CustomEvent("bskyLogout")

  // Regexes
  const atUriPattern = /^at:\/\/(did:plc:[a-z0-9]+)\/?(.+)?$/
  const atPostUriPattern =
    /^at:\/\/(did:plc:[a-z0-9]+)\/app\.bsky\.feed\.post\/([a-z0-9]+)$/

  // Icons
  const bskyIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgd2lkdGg9IjEyOCIKICAgaGVpZ2h0PSIxMjgiCiAgIHZpZXdCb3g9IjAgMCAxMjggMTI4IgogICBmaWxsPSJub25lIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICBzb2RpcG9kaTpkb2NuYW1lPSJ0dXJib2J1dHRlcmZseS1pY29uLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4zLjIgKDA5MWUyMGUsIDIwMjMtMTEtMjUsIGN1c3RvbSkiCiAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnMKICAgICBpZD0iZGVmczEiIC8+PHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJuYW1lZHZpZXcxIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzAwMDAwMCIKICAgICBib3JkZXJvcGFjaXR5PSIwLjI1IgogICAgIGlua3NjYXBlOnNob3dwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZWNoZWNrZXJib2FyZD0iMCIKICAgICBpbmtzY2FwZTpkZXNrY29sb3I9IiNkMWQxZDEiCiAgICAgaW5rc2NhcGU6em9vbT0iMi4yOTQ5MjE0IgogICAgIGlua3NjYXBlOmN4PSIxMDAuNDM5MTciCiAgICAgaW5rc2NhcGU6Y3k9IjkyLjE2MDAxOSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MjAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwOSIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iLTgiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii04IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnMSIgLz48cGF0aAogICAgIGQ9Ik0gMjkuMTI2OTk3LDIxLjMyMjY2IEMgNDMuMzgwMjIyLDMyLjAyMzI4IDU4LjcxMDMyNCw1My43MjAxNDEgNjQuMzM5NjA2LDY1LjM2MjYxMiA2OS45Njg4ODQsNTMuNzIwMTQxIDg1LjI5ODk4NiwzMi4wMjMyOCA5OS41NTIyMTEsMjEuMzIyNjYgMTA5LjgzNjU1LDEzLjYwMTY4MyAxMjYuNTAwNDgsNy42Mjc1NDU1IDEyNi41MDA0OCwyNi42Mzc1NjggYyAwLDMuNzk2NDU1IC0yLjE3NjcyLDMxLjg5MzAzOSAtMy40NTM0MiwzNi40NTQ4NjEgLTQuNDM3NzMsMTUuODU4MjQ5IC0yMC42MDgzMSwxOS45MDMwODEgLTM0Ljk5Mjg2MSwxNy40NTQ5NDkgMjUuMTQzNDIxLDQuMjc5MjQ5IDMxLjUzOTQyMSwxOC40NTM2ODMgMTcuNzI1OTExLDMyLjYyODEwMiAtMjYuMjM0NTEsMjYuOTIwMDUgLTM3LjcwNjI1NCwtNi43NTQzIC00MC42NDU3NjcsLTE1LjM4MjgzNCAtMC41Mzg4NzEsLTEuNTgxODE5IC0wLjc5MTAxOCwtMi4zMjE4NDEgLTAuNzk0NzM3LC0xLjY5MjU3MSAtMC4wMDM3LC0wLjYyOTI3IC0wLjI1NTg2OSwwLjExMDc1MiAtMC43OTQ3NDMsMS42OTI1NzEgQyA2MC42MDUzNTMsMTA2LjQyMTE4IDQ5LjEzMzYwNiwxNDAuMDk1NTMgMjIuODk5MDI1LDExMy4xNzU0OCA5LjA4NTQ5ODksOTkuMDAxMDYxIDE1LjQ4MTU0Niw4NC44MjY2MjcgNDAuNjI1MDEsODAuNTQ3Mzc4IDI2LjI0MDQ1NSw4Mi45OTU1MSAxMC4wNjk5ODIsNzguOTUwNjc4IDUuNjMyMTExMiw2My4wOTI0MjkgNC4zNTU1MDI5LDU4LjUzMDYwNyAyLjE3ODcyMzQsMzAuNDM0MDIzIDIuMTc4NzIzNCwyNi42Mzc1NjggYyAwLC0xOS4wMTAwMjI1IDE2LjY2NDA0MDYsLTEzLjAzNTg4NSAyNi45NDgyNzM2LC01LjMxNDkwOCB6IgogICAgIGZpbGw9IiMwMDAwMDAiCiAgICAgaWQ9InBhdGgxIgogICAgIHN0eWxlPSJmaWxsOiNmZGZkZmQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMjE4ODc1IiAvPjxnCiAgICAgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIgogICAgIGlkPSJnMiIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjAyODg0NjUsMCwwLDEuMDI4ODQ2NSwtMTgyLjI5MDQ1LC0xMTQuMjgxODEpIj48cGF0aAogICAgICAgZD0ibSAyNzQuOTksMTU4Ljg4MSBjIC0wLjA0LDAuMTcgLTAuMDcsMC4zNCAtMC4xMiwwLjUxIC0wLjE1LDAuNjMgLTAuNDYsMi4xMiAtMC43Nyw1LjAzIDAsMC4wNSAwLDAuMDkgLTAuMDEsMC4xMiAxLjcxLDYuODggLTEuMTcsMTEuMDcgLTMuMDgsMTIuOTggLTAuMTIsMC4xMyAtMC4yNSwwLjI1IC0wLjM5LDAuMzcgLTEuODcsMS43IC01LjE0LDMuNzMgLTEwLjAyLDMuNzMgLTIuNDMsMCAtNC43LC0wLjU0IC02LjY4LC0xLjUzIDAuMDUsMi43MyAwLjA4LDYuNDkgMC4wOCwxMS43MSAxLjgsMC42MyAzLjQ1LDEuNjUgNC44NSwyLjk5IDIuNzgsMi42NyA0LjMsNi4yNCA0LjMsMTAuMDUgMCw1LjY2IC0zLjI2LDEwLjU4IC04LjUxLDEyLjgzIC0wLjEzLDAuMDYgLTAuMjcsMC4xMiAtMC40LDAuMTcgLTEuNzYsMC42NyAtMy43NCwxIC02LjA2LDEgLTAuODQsMCAtMS43NCwtMC4wNCAtMi43MiwtMC4xMyAtMC42LC0wLjAzIC0xLjQ4LC0wLjAyIC0yLjUyLDAuMDEgLTEuODksMC4yMSAtNC41NSwwLjQyIC04LjExLDAuNjIgLTAuMDcsMCAtMC4xNCwwLjAxIC0wLjIyLDAuMDEgLTAuNDcsMC4wMiAtMC45MiwwLjAzIC0xLjM2LDAuMDMgLTYuMzcsMCAtMTEuMDIsLTIuMDIgLTEzLjgzLC01Ljk5IC0wLjA2LC0wLjA4IC0wLjExLC0wLjE2IC0wLjE2LC0wLjI0IC0yLjg2LC00LjI3IC0yLjk0LC05LjY3IC0wLjIyLC0xNC4wOCAwLjAyLC0wLjA1IDAuMDUsLTAuMDkgMC4wOCwtMC4xNCAxLjczLC0yLjcyIDQuMjYsLTQuNjYgNy41NCwtNS44IDAuMDQsLTEuOTMgMC4wMywtNC4zNSAtMC4wMywtNy4yMiAtMS42MywwLjY4IC0zLjUxLDEuMDggLTUuNjIsMS4wOCAtNS41NywwIC0xMC4xNywtMy4zMSAtMTEuNzcsLTguMzQgLTAuMzMsLTEuMDIgLTAuNjQsLTIuNTEgLTEuMzYsLTUuODcgLTAuMDMsLTAuMTIgLTAuMDUsLTAuMjQgLTAuMDcsLTAuMzYgbCAtMS40OCwtOC4yNyBjIC0wLjA1LC0wLjE4IC0wLjEyLC0wLjM5IC0wLjIsLTAuNjMgLTAuNzcsLTIuMTkgLTEuMTMsLTQuMDUgLTEuMTMsLTUuODUgMCwtMi4yMyAwLjY1LC01LjYgMy43MywtOC45NiAxLjU1LC0xLjcgNC4zNywtMy45IDguOTEsLTQuNjEgMC41NiwtMC4wOSAxLjEzLC0wLjE0IDEuNywtMC4xNCBoIDExLjA2IGMgMC4yNSwwIDAuNSwwLjAxIDAuNzUsMC4wMyA0LjIyLDAuMTUgOCwwLjE0IDExLjI0LC0wLjAxIDQuNTMsLTAuMiA5LjA1LC0wLjU5IDEzLjQ4LC0xLjE2IDAuNSwtMC4xNiAxLjA0LC0wLjMyIDEuNjIsLTAuNDYgMC41NSwtMC4xNCAxLjExLC0wLjIzIDEuNjcsLTAuMjkgNC4yNiwtMC4zOSA4LjIzLDAuODQgMTEuMzIsMy40OCAzLjgzLDMuMjkgNS41Miw4LjI3IDQuNTEsMTMuMzMgeiIKICAgICAgIGZpbGw9IiMxMTg1ZmUiCiAgICAgICBzdHJva2U9Im5vbmUiCiAgICAgICBzdHJva2Utd2lkdGg9IjEiCiAgICAgICBpZD0icGF0aDEtOSIKICAgICAgIHN0eWxlPSJmaWxsOiMxMTg1ZmU7ZmlsbC1vcGFjaXR5OjEiIC8+PHBhdGgKICAgICAgIGQ9Im0gMjY0LjIwMiwxNTYuNzI1IGMgLTAuNDEsMS42NDMgLTAuNzYyLDMuODcgLTEuMDU1LDYuNjg1IC0wLjExOSwxLjQwOCAtMC4wNjEsMi41NTEgMC4xNzYsMy40MzEgMC40MDgsMS40NjcgMC4zODEsMi40MzUgLTAuMDg4LDIuOTAzIC0wLjY0NiwwLjU4NiAtMS41MjUsMC44NzkgLTIuNjM5LDAuODc5IC0xLjI5MSwwIC0yLjE0MywtMC4zODMgLTIuNTUxLC0xLjE1MSAtMC4wNjEsLTIuMzYyIC0wLjAzMSwtNC41NzggMC4wODgsLTYuNjQ2IDAuMTE1LC0yLjU0IDAuMTc2LC0zLjg2OSAwLjE3NiwtMy45ODcgLTAuMDYxLDAgLTAuMTQ4LC0wLjA1OSAtMC4yNjQsLTAuMTc4IC01LjQ1NSwwLjIzNyAtMTAuNTg2LDAuNTg5IC0xNS4zOTQsMS4wNTkgLTAuMTE4LDAuNTg5IC0wLjExOCwxLjUyOCAwLDIuODIgMC4yMzMsMS44MjIgMC4zNTIsMi44OCAwLjM1MiwzLjE3MiAtMC4yMzQsMS44MjIgLTAuMzUyLDQuNTI0IC0wLjM1Miw4LjEwOSAwLjIzMywxLjUyOCAwLjM1Miw4LjA4IDAuMzUyLDE5LjY1NSB2IDYuNDM1IGMgMCwwLjk5OSAwLjE0NSwxLjcwNCAwLjQzNiwyLjExNSBoIDUuNDAxIGMgMC45ODcsLTAuMTE3IDEuNzg1LDAuMTE4IDIuMzk2LDAuNzA0IDAuNjA5LDAuNTg3IDAuOTE0LDEuMjkgMC45MTQsMi4xMSAwLDEuMjg5IC0wLjYxNSwyLjE5OSAtMS44NDcsMi43MjggLTAuNzYzLDAuMjkyIC0yLjExMSwwLjM1MiAtNC4wNDYsMC4xNzYgLTAuOTM4LC0wLjA2IC0yLjMxNywtMC4wNiAtNC4xMzUsMCAtMS42NDIsMC4yMDQgLTQuMjgsMC40MDkgLTcuOTE2LDAuNjE1IC0zLjE2NywwLjExNyAtNS4xMDIsLTAuMzIzIC01LjgwNiwtMS4zMTkgLTAuNDcsLTAuNzAzIC0wLjQ3LC0xLjQzNyAwLC0yLjE5OSAwLjgyLC0xLjI4OSAyLjk2MSwtMS45MzUgNi40MjIsLTEuOTM1IDEuMjMxLDAgMS45OTIsLTAuMTAyIDIuMjg2LC0wLjMwNyAwLjI5MywtMC4yMDUgMC40NCwtMC42MDEgMC40NCwtMS4xODcgMCwtMC41MjYgMCwtMS4wMjMgMCwtMS40OTIgMCwtMC44NzcgMCwtMi4xNjUgMCwtMy44NjIgMC4xNzYsLTIuOTgzIDAuMTc2LC03LjQzMiAwLC0xMy4zNDMgLTAuMjM1LC04LjQ4NSAtMC4xMTgsLTE1Ljk0NSAwLjM1MiwtMjIuMzgzIC0wLjA1OSwtMC4wNTggLTAuMTQ3LC0wLjE0NiAtMC4yNjYsLTAuMjY0IC0yLjEyMywwLjExOCAtNS41NDMsMC4wNTkgLTEwLjI2LC0wLjE3NyAtMC41MzEsMCAtMi4zMzEsMC4xMTkgLTUuMzk2LDAuMzUzIDAuNzYyLDUuMzM3IDEuMjMxLDkuMzU0IDEuNDA3LDEyLjA1MSAwLDAuMzUyIC0wLjA1OSwxLjE0NCAtMC4xNzYsMi4zNzUgLTAuMDU5LDAuODc5IC0wLjc5MiwxLjMxOSAtMi4xOTksMS4zMTkgLTAuNzYzLDAgLTEuMjAyLC0wLjI2MiAtMS4zMTksLTAuNzg1IC0wLjA1OSwtMC4xMTUgLTAuNDExLC0xLjY4NyAtMS4wNTYsLTQuNzExIC0wLjM1MiwtMS45NzcgLTAuODUxLC00Ljc2OSAtMS40OTUsLTguMzc1IDAsLTAuMjMgLTAuMjA2LC0wLjk1NyAtMC42MTUsLTIuMTggLTAuMzUsLTAuOTg5IC0wLjUyNSwtMS43NDUgLTAuNTI1LC0yLjI2OCAwLC0wLjQwNiAwLjI3NywtMC45MTcgMC44MzYsLTEuNTI2IDAuNTU3LC0wLjYxIDEuMzkzLC0xLjAwNCAyLjUwNywtMS4xNzkgMC4xNzYsMCAwLjQ1MywwIDAuODM2LDAgMC4zOCwwIDAuNjg4LDAgMC45MjMsMCA2Ljk3OSwwIDEwLjAyOCwwIDkuMTQ4LDAgNC43NSwwLjE3NyA4Ljk3MiwwLjE3NyAxMi42NjYsMCA1LjI3NywtMC4yMzMgMTAuNDk1LC0wLjcwMyAxNS42NTcsLTEuNDA3IDAuMzUyLC0wLjE3NiAwLjg3OSwtMC4zNTIgMS41ODIsLTAuNTI3IDEuMjkxLC0wLjExNyAyLjM0NiwwLjE3NiAzLjE2OCwwLjg4IDAuODIsMC43MDIgMS4xMTMsMS42NDEgMC44NzksMi44MTQgeiIKICAgICAgIGZpbGw9IiNmZmZmZmYiCiAgICAgICBzdHJva2U9IiNmZmZmZmYiCiAgICAgICBzdHJva2Utd2lkdGg9IjMiCiAgICAgICBpZD0icGF0aDIiIC8+PC9nPjwvc3ZnPgo="
  const bskyMenuIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgd2lkdGg9IjY0IgogICBoZWlnaHQ9IjY0IgogICB2aWV3Qm94PSIwIDAgNjQgNjQiCiAgIGZpbGw9Im5vbmUiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9InN2ZzEiCiAgIHNvZGlwb2RpOmRvY25hbWU9InR1cmJvYnV0dGVyZmx5LW1lbnUtaWNvbi5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjEuMy4yICgwOTFlMjBlLCAyMDIzLTExLTI1LCBjdXN0b20pIgogICB4bWw6c3BhY2U9InByZXNlcnZlIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzCiAgICAgaWQ9ImRlZnMxIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiMwMDAwMDAiCiAgICAgYm9yZGVyb3BhY2l0eT0iMC4yNSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VjaGVja2VyYm9hcmQ9IjAiCiAgICAgaW5rc2NhcGU6ZGVza2NvbG9yPSIjZDFkMWQxIgogICAgIGlua3NjYXBlOnpvb209IjQuNTg5ODQyOCIKICAgICBpbmtzY2FwZTpjeD0iNjQuMzgxMjkiCiAgICAgaW5rc2NhcGU6Y3k9IjM3LjM2NTExNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MjAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwOSIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iLTgiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii04IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnMSIgLz48Y2lyY2xlCiAgICAgc3R5bGU9ImZpbGw6IzBlOThmZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAxNjlkODtzdHJva2Utd2lkdGg6MS45NzQ3MztzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MTtwYWludC1vcmRlcjpmaWxsIG1hcmtlcnMgc3Ryb2tlO2ZpbGwtb3BhY2l0eToxIgogICAgIGlkPSJwYXRoMyIKICAgICBjeD0iMzEuOTMxNjg4IgogICAgIGN5PSIzMS45MzE2ODgiCiAgICAgcj0iMzAuOTQ0MzIzIiAvPjxwYXRoCiAgICAgZD0ibSAxNy40MTU0NjEsMTQuNjc1Mjk0IGMgNS42MDUxMTUsNC4yMDgwNDQgMTEuNjMzNzEzLDEyLjc0MDM4NCAxMy44NDc0MzksMTcuMzE4ODEyIDIuMjEzNzI3LC00LjU3ODQyOCA4LjI0MjMyNCwtMTMuMTEwNzY4IDEzLjg0NzQ0LC0xNy4zMTg4MTIgNC4wNDQzMzgsLTMuMDM2MjkxIDEwLjU5NzQ2OSwtNS4zODU2MzI1IDEwLjU5NzQ2OSwyLjA5MDEwMyAwLDEuNDkyOTYzIC0wLjg1NjAwMiwxMi41NDIwMSAtMS4zNTgwNywxNC4zMzU5NTUgLTEuNzQ1MTQyLDYuMjM2Mjk0IC04LjEwNDI2Nyw3LjgyNjkzNSAtMTMuNzYxMDI0LDYuODY0MTk3IDkuODg3NzEsMS42ODI4MjcgMTIuNDAyOTU1LDcuMjU2OTU0IDYuOTcwNzYyLDEyLjgzMTA4IEMgMzcuMjQyNjk1LDYxLjM4Mjk5NSAzMi43MzE0LDQ4LjE0MDQ4MyAzMS41NzU0MjksNDQuNzQ3Mjk0IDMxLjM2MzUxNyw0NC4xMjUyNDEgMzEuMjY0MzYzLDQzLjgzNDIyNSAzMS4yNjI5LDQ0LjA4MTY4NiBjIC0wLjAwMTMsLTAuMjQ3NDYxIC0wLjEwMDYyMiwwLjA0MzU0IC0wLjMxMjUzNSwwLjY2NTYwOCAtMS4xNTU5NywzLjM5MzE4OSAtNS42NjcyNTksMTYuNjM1NzAxIC0xNS45ODQwNjgsNi4wNDkzMzUgQyA5LjUzNDA5NDgsNDUuMjIyNTAzIDEyLjA0OTM1NiwzOS42NDgzNzYgMjEuOTM3MDc5LDM3Ljk2NTU0OSAxNi4yODAzMjIsMzguOTI4Mjg3IDkuOTIxMjQ1NiwzNy4zMzc2NDYgOC4xNzYwNDMxLDMxLjEwMTM1MiA3LjY3NDAxMzMsMjkuMzA3NDA3IDYuODE3OTkwMSwxOC4yNTgzNiA2LjgxNzk5MDEsMTYuNzY1Mzk3IGMgMCwtNy40NzU3MzU1IDYuNTUzMTcxOSwtNS4xMjYzOTQgMTAuNTk3NDcwOSwtMi4wOTAxMDMgeiIKICAgICBmaWxsPSIjMDAwMDAwIgogICAgIGlkPSJwYXRoMSIKICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZS13aWR0aDowLjA4NjA3MzMiIC8+PGcKICAgICBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiCiAgICAgaWQ9ImcyIgogICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuNDA0NTk2MjIsMCwwLDAuNDA0NTk2MjIsLTY1LjcyNDkyNiwtMzguNjUxNDcyKSI+PHBhdGgKICAgICAgIGQ9Im0gMjc0Ljk5LDE1OC44ODEgYyAtMC4wNCwwLjE3IC0wLjA3LDAuMzQgLTAuMTIsMC41MSAtMC4xNSwwLjYzIC0wLjQ2LDIuMTIgLTAuNzcsNS4wMyAwLDAuMDUgMCwwLjA5IC0wLjAxLDAuMTIgMS43MSw2Ljg4IC0xLjE3LDExLjA3IC0zLjA4LDEyLjk4IC0wLjEyLDAuMTMgLTAuMjUsMC4yNSAtMC4zOSwwLjM3IC0xLjg3LDEuNyAtNS4xNCwzLjczIC0xMC4wMiwzLjczIC0yLjQzLDAgLTQuNywtMC41NCAtNi42OCwtMS41MyAwLjA1LDIuNzMgMC4wOCw2LjQ5IDAuMDgsMTEuNzEgMS44LDAuNjMgMy40NSwxLjY1IDQuODUsMi45OSAyLjc4LDIuNjcgNC4zLDYuMjQgNC4zLDEwLjA1IDAsNS42NiAtMy4yNiwxMC41OCAtOC41MSwxMi44MyAtMC4xMywwLjA2IC0wLjI3LDAuMTIgLTAuNCwwLjE3IC0xLjc2LDAuNjcgLTMuNzQsMSAtNi4wNiwxIC0wLjg0LDAgLTEuNzQsLTAuMDQgLTIuNzIsLTAuMTMgLTAuNiwtMC4wMyAtMS40OCwtMC4wMiAtMi41MiwwLjAxIC0xLjg5LDAuMjEgLTQuNTUsMC40MiAtOC4xMSwwLjYyIC0wLjA3LDAgLTAuMTQsMC4wMSAtMC4yMiwwLjAxIC0wLjQ3LDAuMDIgLTAuOTIsMC4wMyAtMS4zNiwwLjAzIC02LjM3LDAgLTExLjAyLC0yLjAyIC0xMy44MywtNS45OSAtMC4wNiwtMC4wOCAtMC4xMSwtMC4xNiAtMC4xNiwtMC4yNCAtMi44NiwtNC4yNyAtMi45NCwtOS42NyAtMC4yMiwtMTQuMDggMC4wMiwtMC4wNSAwLjA1LC0wLjA5IDAuMDgsLTAuMTQgMS43MywtMi43MiA0LjI2LC00LjY2IDcuNTQsLTUuOCAwLjA0LC0xLjkzIDAuMDMsLTQuMzUgLTAuMDMsLTcuMjIgLTEuNjMsMC42OCAtMy41MSwxLjA4IC01LjYyLDEuMDggLTUuNTcsMCAtMTAuMTcsLTMuMzEgLTExLjc3LC04LjM0IC0wLjMzLC0xLjAyIC0wLjY0LC0yLjUxIC0xLjM2LC01Ljg3IC0wLjAzLC0wLjEyIC0wLjA1LC0wLjI0IC0wLjA3LC0wLjM2IGwgLTEuNDgsLTguMjcgYyAtMC4wNSwtMC4xOCAtMC4xMiwtMC4zOSAtMC4yLC0wLjYzIC0wLjc3LC0yLjE5IC0xLjEzLC00LjA1IC0xLjEzLC01Ljg1IDAsLTIuMjMgMC42NSwtNS42IDMuNzMsLTguOTYgMS41NSwtMS43IDQuMzcsLTMuOSA4LjkxLC00LjYxIDAuNTYsLTAuMDkgMS4xMywtMC4xNCAxLjcsLTAuMTQgaCAxMS4wNiBjIDAuMjUsMCAwLjUsMC4wMSAwLjc1LDAuMDMgNC4yMiwwLjE1IDgsMC4xNCAxMS4yNCwtMC4wMSA0LjUzLC0wLjIgOS4wNSwtMC41OSAxMy40OCwtMS4xNiAwLjUsLTAuMTYgMS4wNCwtMC4zMiAxLjYyLC0wLjQ2IDAuNTUsLTAuMTQgMS4xMSwtMC4yMyAxLjY3LC0wLjI5IDQuMjYsLTAuMzkgOC4yMywwLjg0IDExLjMyLDMuNDggMy44MywzLjI5IDUuNTIsOC4yNyA0LjUxLDEzLjMzIHoiCiAgICAgICBmaWxsPSIjMTE4NWZlIgogICAgICAgc3Ryb2tlPSJub25lIgogICAgICAgc3Ryb2tlLXdpZHRoPSIxIgogICAgICAgaWQ9InBhdGgxLTkiCiAgICAgICBzdHlsZT0iZmlsbDojMTE4NWZlO2ZpbGwtb3BhY2l0eToxIiAvPjxwYXRoCiAgICAgICBkPSJtIDI2NC4yMDIsMTU2LjcyNSBjIC0wLjQxLDEuNjQzIC0wLjc2MiwzLjg3IC0xLjA1NSw2LjY4NSAtMC4xMTksMS40MDggLTAuMDYxLDIuNTUxIDAuMTc2LDMuNDMxIDAuNDA4LDEuNDY3IDAuMzgxLDIuNDM1IC0wLjA4OCwyLjkwMyAtMC42NDYsMC41ODYgLTEuNTI1LDAuODc5IC0yLjYzOSwwLjg3OSAtMS4yOTEsMCAtMi4xNDMsLTAuMzgzIC0yLjU1MSwtMS4xNTEgLTAuMDYxLC0yLjM2MiAtMC4wMzEsLTQuNTc4IDAuMDg4LC02LjY0NiAwLjExNSwtMi41NCAwLjE3NiwtMy44NjkgMC4xNzYsLTMuOTg3IC0wLjA2MSwwIC0wLjE0OCwtMC4wNTkgLTAuMjY0LC0wLjE3OCAtNS40NTUsMC4yMzcgLTEwLjU4NiwwLjU4OSAtMTUuMzk0LDEuMDU5IC0wLjExOCwwLjU4OSAtMC4xMTgsMS41MjggMCwyLjgyIDAuMjMzLDEuODIyIDAuMzUyLDIuODggMC4zNTIsMy4xNzIgLTAuMjM0LDEuODIyIC0wLjM1Miw0LjUyNCAtMC4zNTIsOC4xMDkgMC4yMzMsMS41MjggMC4zNTIsOC4wOCAwLjM1MiwxOS42NTUgdiA2LjQzNSBjIDAsMC45OTkgMC4xNDUsMS43MDQgMC40MzYsMi4xMTUgaCA1LjQwMSBjIDAuOTg3LC0wLjExNyAxLjc4NSwwLjExOCAyLjM5NiwwLjcwNCAwLjYwOSwwLjU4NyAwLjkxNCwxLjI5IDAuOTE0LDIuMTEgMCwxLjI4OSAtMC42MTUsMi4xOTkgLTEuODQ3LDIuNzI4IC0wLjc2MywwLjI5MiAtMi4xMTEsMC4zNTIgLTQuMDQ2LDAuMTc2IC0wLjkzOCwtMC4wNiAtMi4zMTcsLTAuMDYgLTQuMTM1LDAgLTEuNjQyLDAuMjA0IC00LjI4LDAuNDA5IC03LjkxNiwwLjYxNSAtMy4xNjcsMC4xMTcgLTUuMTAyLC0wLjMyMyAtNS44MDYsLTEuMzE5IC0wLjQ3LC0wLjcwMyAtMC40NywtMS40MzcgMCwtMi4xOTkgMC44MiwtMS4yODkgMi45NjEsLTEuOTM1IDYuNDIyLC0xLjkzNSAxLjIzMSwwIDEuOTkyLC0wLjEwMiAyLjI4NiwtMC4zMDcgMC4yOTMsLTAuMjA1IDAuNDQsLTAuNjAxIDAuNDQsLTEuMTg3IDAsLTAuNTI2IDAsLTEuMDIzIDAsLTEuNDkyIDAsLTAuODc3IDAsLTIuMTY1IDAsLTMuODYyIDAuMTc2LC0yLjk4MyAwLjE3NiwtNy40MzIgMCwtMTMuMzQzIC0wLjIzNSwtOC40ODUgLTAuMTE4LC0xNS45NDUgMC4zNTIsLTIyLjM4MyAtMC4wNTksLTAuMDU4IC0wLjE0NywtMC4xNDYgLTAuMjY2LC0wLjI2NCAtMi4xMjMsMC4xMTggLTUuNTQzLDAuMDU5IC0xMC4yNiwtMC4xNzcgLTAuNTMxLDAgLTIuMzMxLDAuMTE5IC01LjM5NiwwLjM1MyAwLjc2Miw1LjMzNyAxLjIzMSw5LjM1NCAxLjQwNywxMi4wNTEgMCwwLjM1MiAtMC4wNTksMS4xNDQgLTAuMTc2LDIuMzc1IC0wLjA1OSwwLjg3OSAtMC43OTIsMS4zMTkgLTIuMTk5LDEuMzE5IC0wLjc2MywwIC0xLjIwMiwtMC4yNjIgLTEuMzE5LC0wLjc4NSAtMC4wNTksLTAuMTE1IC0wLjQxMSwtMS42ODcgLTEuMDU2LC00LjcxMSAtMC4zNTIsLTEuOTc3IC0wLjg1MSwtNC43NjkgLTEuNDk1LC04LjM3NSAwLC0wLjIzIC0wLjIwNiwtMC45NTcgLTAuNjE1LC0yLjE4IC0wLjM1LC0wLjk4OSAtMC41MjUsLTEuNzQ1IC0wLjUyNSwtMi4yNjggMCwtMC40MDYgMC4yNzcsLTAuOTE3IDAuODM2LC0xLjUyNiAwLjU1NywtMC42MSAxLjM5MywtMS4wMDQgMi41MDcsLTEuMTc5IDAuMTc2LDAgMC40NTMsMCAwLjgzNiwwIDAuMzgsMCAwLjY4OCwwIDAuOTIzLDAgNi45NzksMCAxMC4wMjgsMCA5LjE0OCwwIDQuNzUsMC4xNzcgOC45NzIsMC4xNzcgMTIuNjY2LDAgNS4yNzcsLTAuMjMzIDEwLjQ5NSwtMC43MDMgMTUuNjU3LC0xLjQwNyAwLjM1MiwtMC4xNzYgMC44NzksLTAuMzUyIDEuNTgyLC0wLjUyNyAxLjI5MSwtMC4xMTcgMi4zNDYsMC4xNzYgMy4xNjgsMC44OCAwLjgyLDAuNzAyIDEuMTEzLDEuNjQxIDAuODc5LDIuODE0IHoiCiAgICAgICBmaWxsPSIjZmZmZmZmIgogICAgICAgc3Ryb2tlPSIjZmZmZmZmIgogICAgICAgc3Ryb2tlLXdpZHRoPSIzIgogICAgICAgaWQ9InBhdGgyIiAvPjwvZz48L3N2Zz4K"
  const speechBubbleIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIEdlbmVyYXRvcjogU1ZHIFJlcG8gTWl4ZXIgVG9vbHMgLS0+Cgo8c3ZnCiAgIGZpbGw9IiMwMDAwMDAiCiAgIGhlaWdodD0iODAwcHgiCiAgIHdpZHRoPSI4MDBweCIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0iQ2FwYV8xIgogICB2aWV3Qm94PSIwIDAgMzcxLjExNyAzNzEuMTE3IgogICB4bWw6c3BhY2U9InByZXNlcnZlIgogICBzb2RpcG9kaTpkb2NuYW1lPSJibGFjay1zcGVlY2gtYnViYmxlLXN2Z3JlcG8tY29tLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4zLjIgKDA5MWUyMGUsIDIwMjMtMTEtMjUsIGN1c3RvbSkiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnMKICAgaWQ9ImRlZnMxIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXcKICAgaWQ9Im5hbWVkdmlldzEiCiAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgYm9yZGVyY29sb3I9IiMwMDAwMDAiCiAgIGJvcmRlcm9wYWNpdHk9IjAuMjUiCiAgIGlua3NjYXBlOnNob3dwYWdlc2hhZG93PSIyIgogICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICBpbmtzY2FwZTpkZXNrY29sb3I9IiNkMWQxZDEiCiAgIGlua3NjYXBlOnpvb209IjEuMDE2MjUiCiAgIGlua3NjYXBlOmN4PSI0MDAiCiAgIGlua3NjYXBlOmN5PSI0MDAiCiAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTkyMCIKICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwOSIKICAgaW5rc2NhcGU6d2luZG93LXg9Ii04IgogICBpbmtzY2FwZTp3aW5kb3cteT0iLTgiCiAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkNhcGFfMSIgLz4KPHBhdGgKICAgZD0iTTMxNi4zMyw2NC41NTZjLTM0Ljk4Mi0yNy42MDctODEuNDI0LTQyLjgxMS0xMzAuNzcyLTQyLjgxMWMtNDkuMzQ4LDAtOTUuNzksMTUuMjA0LTEzMC43NzEsNDIuODExICBDMTkuNDU3LDkyLjQzOCwwLDEyOS42MTUsMCwxNjkuMjM4YzAsMjMuODM1LDcuMzA4LDQ3LjUwOCwyMS4xMzMsNjguNDZjMTIuNzU5LDE5LjMzNSwzMS4wNywzNi40Miw1My4wODgsNDkuNTY0ICBjLTEuMDE2LDcuMTE2LTYuNDg3LDI3Ljk0MS0zNS44ODgsNTIuNzU5Yy0xLjUxMywxLjI3OC0yLjEzLDMuMzI4LTEuNTcyLDUuMjI5YzAuNTU4LDEuOSwyLjE4NSwzLjI5Miw0LjE0OCwzLjU1ICBjMC4xNzgsMC4wMjMsNC40NTQsMC41NzIsMTIuMDUyLDAuNTcyYzIxLjY2NSwwLDY1LjkzOS00LjMwMiwxMjAuMDYzLTMyLjk3M2M0LjE3NywwLjIyMSw4LjM4NywwLjMzMywxMi41MzQsMC4zMzMgIGM0OS4zNDgsMCw5NS43ODktMTUuMjA0LDEzMC43NzItNDIuODExYzM1LjMzLTI3Ljg4Miw1NC43ODctNjUuMDU5LDU0Ljc4Ny0xMDQuNjgzQzM3MS4xMTcsMTI5LjYxNSwzNTEuNjYsOTIuNDM4LDMxNi4zMyw2NC41NTZ6IgogICBpZD0icGF0aDEiCiAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiIC8+Cjwvc3ZnPgo="
  const TwoSpeechBubbleIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIEdlbmVyYXRvcjogU1ZHIFJlcG8gTWl4ZXIgVG9vbHMgLS0+Cgo8c3ZnCiAgIGZpbGw9IiMwMDAwMDAiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9IkNhcGFfMSIKICAgd2lkdGg9IjgwMHB4IgogICBoZWlnaHQ9IjgwMHB4IgogICB2aWV3Qm94PSIwIDAgNDQxLjYgNDQxLjYiCiAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgIHNvZGlwb2RpOmRvY25hbWU9InR3by1zcGVlY2gtYnViYmxlcy1zdmdyZXBvLWNvbS5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjEuMy4yICgwOTFlMjBlLCAyMDIzLTExLTI1LCBjdXN0b20pIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzCiAgIGlkPSJkZWZzMyIgLz48c29kaXBvZGk6bmFtZWR2aWV3CiAgIGlkPSJuYW1lZHZpZXczIgogICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgIGJvcmRlcmNvbG9yPSIjMDAwMDAwIgogICBib3JkZXJvcGFjaXR5PSIwLjI1IgogICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMiIKICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgaW5rc2NhcGU6cGFnZWNoZWNrZXJib2FyZD0iMCIKICAgaW5rc2NhcGU6ZGVza2NvbG9yPSIjZDFkMWQxIgogICBpbmtzY2FwZTp6b29tPSIxLjAxNjI1IgogICBpbmtzY2FwZTpjeD0iNDAwIgogICBpbmtzY2FwZTpjeT0iNDAwIgogICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MjAiCiAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMDkiCiAgIGlua3NjYXBlOndpbmRvdy14PSItOCIKICAgaW5rc2NhcGU6d2luZG93LXk9Ii04IgogICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJDYXBhXzEiIC8+CjxnCiAgIGlkPSJnMyIKICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSI+Cgk8ZwogICBpZD0iZzIiCiAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiPgoJCTxwYXRoCiAgIGQ9Ik00MDYuOTc1LDIwNS4wNDZ2NS4wODdjMCw0Ni4yOTQtMzcuNjYzLDgzLjk1OC04My45NTgsODMuOTU4SDIwMS4wNzF2MTAuNDcyYzAsMjIuMTM5LDE3Ljk0Niw0MC4wODQsNDAuMDgzLDQwLjA4NCAgICBoMTAxLjkzOGw0Ni4xNTgsNDUuNDExYzEuNjQ1LDEuNjE3LDMuODI4LDIuNDc3LDYuMDQ3LDIuNDc3YzEuMTIzLDAsMi4yNTQtMC4yMjEsMy4zMy0wLjY3YzMuMjA0LTEuMzQ0LDUuMjg5LTQuNDc5LDUuMjg5LTcuOTUxICAgIHYtMzkuMzQ1YzIxLjAxOS0xLjI0MiwzNy42ODMtMTguNjc1LDM3LjY4My00MC4wMDZWMjQ0Ljc1QzQ0MS42LDIyNC40NjcsNDI2LjUyOCwyMDcuNzExLDQwNi45NzUsMjA1LjA0NnoiCiAgIGlkPSJwYXRoMSIKICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSIgLz4KCQk8cGF0aAogICBkPSJNMzgzLjc4NywyMDguNDU5di05NS40MzdjMC0zNS4zMjMtMjguNjM2LTYzLjk1OC02My45NTgtNjMuOTU4SDYzLjk1OEMyOC42MzUsNDkuMDY0LDAsNzcuNjk5LDAsMTEzLjAyMnY5NS40MzcgICAgYzAsMzQuMDM3LDI2LjU4OSw2MS44NTEsNjAuMTI2LDYzLjgzM3Y2Mi43NzdjMCw1LjU0MiwzLjMyNywxMC41NDQsOC40MzgsMTIuNjg2YzEuNzE4LDAuNzIxLDMuNTIyLDEuMDY5LDUuMzEzLDEuMDY5ICAgIGMzLjU0MiwwLDcuMDI1LTEuMzY4LDkuNjQ5LTMuOTVsNzMuNjUtNzIuNDU3aDE2Mi42NTFDMzU1LjE1MiwyNzIuNDE4LDM4My43ODcsMjQzLjc4MywzODMuNzg3LDIwOC40NTl6IgogICBpZD0icGF0aDIiCiAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiIC8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg=="
  const ImageIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIFRyYW5zZm9ybWVkIGJ5OiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4KCjxzdmcKICAgd2lkdGg9IjY0cHgiCiAgIGhlaWdodD0iNjRweCIKICAgdmlld0JveD0iMCAwIDM2LjgyIDM2LjgyIgogICBmaWxsPSIjMDAwMDAwIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICBzb2RpcG9kaTpkb2NuYW1lPSJwaG90by1pbWFnZS5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjEuMy4yICgwOTFlMjBlLCAyMDIzLTExLTI1LCBjdXN0b20pIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnMxIiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiMwMDAwMDAiCiAgICAgYm9yZGVyb3BhY2l0eT0iMC4yNSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VjaGVja2VyYm9hcmQ9IjAiCiAgICAgaW5rc2NhcGU6ZGVza2NvbG9yPSIjZDFkMWQxIgogICAgIGlua3NjYXBlOnpvb209IjguOTgyNDY1OCIKICAgICBpbmtzY2FwZTpjeD0iMTYuNjk5MjAxIgogICAgIGlua3NjYXBlOmN5PSIzMC4xMTQyMjUiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMDkiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9Ii04IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItOCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9InN2ZzEiIC8+CiAgPGcKICAgICBpZD0iU1ZHUmVwb19iZ0NhcnJpZXIiCiAgICAgc3Ryb2tlLXdpZHRoPSIwIgogICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC41MTIzODcxNCwyLjM2OTc5MDUpIiAvPgogIDxnCiAgICAgaWQ9IlNWR1JlcG9fdHJhY2VyQ2FycmllciIKICAgICBzdHJva2UtbGluZWNhcD0icm91bmQiCiAgICAgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIKICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuNTEyMzg3MTQsMi4zNjk3OTA1KSIgLz4KICA8ZwogICAgIGlkPSJTVkdSZXBvX2ljb25DYXJyaWVyIgogICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC40MDk0NTY2LDIuNDA5MDk4MSkiPgogICAgPGcKICAgICAgIGlkPSJMYWdlcl82MSIKICAgICAgIGRhdGEtbmFtZT0iTGFnZXIgNjEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyKSIKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIGlkPSJFbGxpcHNlXzUiCiAgICAgICAgIGRhdGEtbmFtZT0iRWxsaXBzZSA1IgogICAgICAgICBjeD0iNCIKICAgICAgICAgY3k9IjQiCiAgICAgICAgIHI9IjQiCiAgICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYsOCkiCiAgICAgICAgIGZpbGw9IiNmZmZmZmYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiIC8+CiAgICAgIDxnCiAgICAgICAgIGlkPSJHcm91cF8yOCIKICAgICAgICAgZGF0YS1uYW1lPSJHcm91cCAyOCIKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSI+CiAgICAgICAgPHJlY3QKICAgICAgICAgICBpZD0iUmVjdGFuZ2xlXzM1IgogICAgICAgICAgIGRhdGEtbmFtZT0iUmVjdGFuZ2xlIDM1IgogICAgICAgICAgIHdpZHRoPSIyNi42NDIiCiAgICAgICAgICAgaGVpZ2h0PSIzLjk2NjAwMDEiCiAgICAgICAgICAgcng9IjEuOTgzIgogICAgICAgICAgIHRyYW5zZm9ybT0icm90YXRlKC00NSwzOC44MjMyMjQsOC43NTY4OTQpIgogICAgICAgICAgIGZpbGw9IiNmZmZmZmYiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSIKICAgICAgICAgICB4PSIwIgogICAgICAgICAgIHk9IjAiIC8+CiAgICAgIDwvZz4KICAgICAgPGcKICAgICAgICAgaWQ9Ikdyb3VwXzI5IgogICAgICAgICBkYXRhLW5hbWU9Ikdyb3VwIDI5IgogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxIj4KICAgICAgICA8cmVjdAogICAgICAgICAgIGlkPSJSZWN0YW5nbGVfMzYiCiAgICAgICAgICAgZGF0YS1uYW1lPSJSZWN0YW5nbGUgMzYiCiAgICAgICAgICAgd2lkdGg9IjMuOTQzMDAwMSIKICAgICAgICAgICBoZWlnaHQ9IjE1LjMzNyIKICAgICAgICAgICByeD0iMS45NzIiCiAgICAgICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoLTQ1LDI3LjQ1NzE5NiwtMTguNTg0MTQzKSIKICAgICAgICAgICBmaWxsPSIjZmZmZmZmIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjEiCiAgICAgICAgICAgeD0iMCIKICAgICAgICAgICB5PSIwIiAvPgogICAgICA8L2c+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJQYXRoXzc1IgogICAgICAgICBkYXRhLW5hbWU9IlBhdGggNzUiCiAgICAgICAgIGQ9Ik0gMzIsMCBIIDAgYSAyLDIgMCAwIDAgLTIsMiB2IDI4IGEgMiwyIDAgMCAwIDIsMiBoIDMyIGEgMiwyIDAgMCAwIDIsLTIgViAyIEEgMiwyIDAgMCAwIDMyLDAgWiBtIC0yLDI3IGEgMSwxIDAgMCAxIC0xLDEgSCAzIEEgMSwxIDAgMCAxIDIsMjcgViA1IEEgMSwxIDAgMCAxIDMsNCBoIDI2IGEgMSwxIDAgMCAxIDEsMSB6IgogICAgICAgICBmaWxsPSIjZmZmZmZmIgogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxIiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg=="
  const HeartPlusIcon =
    "data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KDTwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIFRyYW5zZm9ybWVkIGJ5OiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4KPHN2ZyBmaWxsPSIjZmZmZmZmIiB3aWR0aD0iNjRweCIgaGVpZ2h0PSI2NHB4IiB2aWV3Qm94PSIwIDAgMzIgMzIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMC4wMDAzMiI+Cg08ZyBpZD0iU1ZHUmVwb19iZ0NhcnJpZXIiIHN0cm9rZS13aWR0aD0iMCIvPgoNPGcgaWQ9IlNWR1JlcG9fdHJhY2VyQ2FycmllciIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cg08ZyBpZD0iU1ZHUmVwb19pY29uQ2FycmllciI+IDx0aXRsZT5oZWFydDE8L3RpdGxlPiA8cGF0aCBkPSJNMjQgMTIuOTc3Yy0zLjg2NiAwLTcgMy4xNTgtNyA3LjA1NSAwIDIuMjIgMS4wMjAgNC4xOTcgMi42MDkgNS40OTEtMi4wNTYgMS41MjUtMy42MDkgMi40ODgtMy42MDkgMi40ODhzLTE0LTguNjUyLTE0LTE1LjYyMmMwLTQuMiAyLjU4My04LjM5OSA3LjUtOC4zOTkgNC41IDAgNi41IDQuMjk2IDYuNSA0LjI5NnMxLjc1LTQuMjk2IDYuNS00LjI5NiA3LjQxNiA0LjExNSA3LjQxNiA4LjM5OWMwIDAuOTU4LTAuMjcyIDEuOTQzLTAuNzE2IDIuOTMyLTEuMjgxLTEuNDM2LTMuMTM0LTIuMzQ0LTUuMi0yLjM0NHpNMjQgMTMuOTg0YzMuMzEzIDAgNiAyLjcwNyA2IDYuMDQ3cy0yLjY4NyA2LjA0OC02IDYuMDQ4Yy0zLjMxNCAwLTYtMi43MDgtNi02LjA0OHMyLjY4Ni02LjA0NyA2LTYuMDQ3ek0yMSAyMS4wMzloMnYyLjAxNmgydi0yLjAxNmgydi0yLjAxNmgtMnYtMi4wMTZoLTJ2Mi4wMTZoLTJ2Mi4wMTZ6Ii8+IDwvZz4KDTwvc3ZnPg=="
  const HeartBrokenIcon =
    "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIFRyYW5zZm9ybWVkIGJ5OiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4KCjxzdmcKICAgZmlsbD0iIzAwMDAwMCIKICAgd2lkdGg9IjY0cHgiCiAgIGhlaWdodD0iNjRweCIKICAgdmlld0JveD0iMCAwIDMyIDMyIgogICB2ZXJzaW9uPSIxLjEiCiAgIHN0cm9rZT0iIzAwMDAwMCIKICAgc3Ryb2tlLXdpZHRoPSIwLjAwMDMyIgogICB0cmFuc2Zvcm09InJvdGF0ZSgwKSIKICAgaWQ9InN2ZzEiCiAgIHNvZGlwb2RpOmRvY25hbWU9ImhlYXJ0LXN2Z3JlcG8tY29tLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4zLjIgKDA5MWUyMGUsIDIwMjMtMTEtMjUsIGN1c3RvbSkiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczEiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJuYW1lZHZpZXcxIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzAwMDAwMCIKICAgICBib3JkZXJvcGFjaXR5PSIwLjI1IgogICAgIGlua3NjYXBlOnNob3dwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZWNoZWNrZXJib2FyZD0iMCIKICAgICBpbmtzY2FwZTpkZXNrY29sb3I9IiNkMWQxZDEiCiAgICAgaW5rc2NhcGU6em9vbT0iNi4zNTE1NjI1IgogICAgIGlua3NjYXBlOmN4PSItNC42NDQ1MjY0IgogICAgIGlua3NjYXBlOmN5PSIyMy41Mzc1MTUiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMDkiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9Ii04IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItOCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9InN2ZzEiIC8+CiAgPGcKICAgICBpZD0iU1ZHUmVwb19iZ0NhcnJpZXIiCiAgICAgc3Ryb2tlLXdpZHRoPSIwIiAvPgogIDxnCiAgICAgaWQ9IlNWR1JlcG9fdHJhY2VyQ2FycmllciIKICAgICBzdHJva2UtbGluZWNhcD0icm91bmQiCiAgICAgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIKICAgICBzdHJva2U9IiNDQ0NDQ0MiCiAgICAgc3Ryb2tlLXdpZHRoPSIwLjI1NiIgLz4KICA8ZwogICAgIGlkPSJTVkdSZXBvX2ljb25DYXJyaWVyIgogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMDkzNzM5MywwLDAsMS4wOTM3MzkzLC0xLjM1NTg5MzEsMC42NTk3NDc5MikiCiAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSI+CiAgICA8dGl0bGUKICAgICAgIGlkPSJ0aXRsZTEiPmhlYXJ0PC90aXRsZT4KICAgIDxwYXRoCiAgICAgICBpZD0icGF0aDEiCiAgICAgICBkPSJtIDkuNTQxOTkyMiw0LjA4MzAwNzggYyAtNC45MTY5OTUxLDAgLTcuNSw0LjE2NzAxMiAtNy41LDguMzMzMDA4MiAwLDYuMTk2NTk0IDExLjE1ODY1MTgsMTMuNjc4NjM0IDEzLjQ5OTAyMzgsMTUuMTgwNjY0IEwgMTEuNTM3MTA5LDIxLjEyNSBjIC0wLjE1NDQ1MSwtMC4zMjg2OTMgLTAuMTk5NjksLTAuNDQwMTIzIDAuMDUwNzgsLTAuNzIwNzAzIEwgMTYuMjM0Mzc1LDE0LjY2Nzk2OSAxMy42MTAzNTIsNS40NTg5ODQ0IEMgMTIuNTk1NDE3LDQuNjk3MzY1OSAxMS4yNDk1NCw0LjA4MzAwNzggOS41NDE5OTIyLDQuMDgzMDA3OCBaIG0gMTIuOTk5OTk5OCwwIGMgLTQuNzQ5OTk1LDAgLTYuNSw0LjI2MTcxODggLTYuNSw0LjI2MTcxODggbCAxLjUwMDk3Nyw2LjE2MjEwOTQgYyAwLjA0MDM4LDAuMjgyMDY0IDAuMDc2NDQsMC40NTkxNTcgLTAuMTI4OTA3LDAuNzAwMTk1IGwgLTQuNTcyMjY1LDUuNjQyNTc4IDMuODY5MTQxLDYuMjUgYyAwLjA2ODk3LDAuMTExMjgxIDAuMDk3MTgsMC4yMjA0MzcgMC4xMDA1ODUsMC4zMjQyMTkgMi44OTA4NDksLTEuODg0NzU0IDEzLjE0NjQ4NSwtOC45OTIzNzMgMTMuMTQ2NDg1LC0xNS4wMDc4MTIgMCwtNC4yNDk5OTYxIC0yLjY2NjAyMSwtOC4zMzMwMDgyIC03LjQxNjAxNiwtOC4zMzMwMDgyIHoiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9InNzY2NjY2Nzc2NjY2NjY3NzIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MSIgLz4KICA8L2c+Cjwvc3ZnPgo="
  const SearchingLensIcon =
    "data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KDTwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIFRyYW5zZm9ybWVkIGJ5OiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4KPHN2ZyBmaWxsPSIjZmZmZmZmIiB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHZpZXdCb3g9IjAgMCA0NS45MjMgNDUuOTIzIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMC4wMDA0NTkyMzAwMDAwMDAwMDAwMyI+Cg08ZyBpZD0iU1ZHUmVwb19iZ0NhcnJpZXIiIHN0cm9rZS13aWR0aD0iMCIvPgoNPGcgaWQ9IlNWR1JlcG9fdHJhY2VyQ2FycmllciIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cg08ZyBpZD0iU1ZHUmVwb19pY29uQ2FycmllciI+IDxnPiA8cGF0aCBkPSJNNDUuNDk0LDQ0LjQ0M2MtMC4wMDQsMC4zODctMC4wMjUsMC42MTEtMC4wMjUsMC42MTFsLTAuODM4LDAuODM4YzAsMC0wLjIyNSwwLjAyMS0wLjYxMiwwLjAyNSBjLTAuMiwwLjAxLTAuNDMsMC4wMDItMC42OTYtMC4wMWMtMC4yNjYtMC4wMTMtMC41ODQtMC4wMTMtMC44OTgtMC4wNTdjLTAuNjUtMC4wNjQtMS40MzgtMC4xNDYtMi4yNDItMC4zMzggYy0wLjgxNi0wLjE4LTEuNjk5LTAuNDIxLTIuNTgyLTAuNzY0Yy0wLjg5MS0wLjMzNi0xLjgwMi0wLjc1Mi0yLjY4OC0xLjI3MWMtMC44OTEtMC41MTUtMS43NjQtMS4xMjMtMi41MDItMS45MTcgYy0wLjc0OC0wLjc4NC0xLjM0OC0xLjc3LTEuOTI4LTIuNzk3Yy0wLjU4LTEuMDMtMS4xNzctMi4wNjctMS44NjEtMy4wMTljLTAuOTYxLTEuMzI5LTEuODkxLTIuNjY0LTIuNzg3LTMuOTg4IGMyLjI2Ni0xLjM2Miw0LjIyMi0zLjE4NCw1LjcyMS01LjM1MmMxLjI1MiwwLjg1MywyLjUxMiwxLjczMSwzLjc2OCwyLjY0YzAuOTUxLDAuNjg0LDEuOTg4LDEuMjgsMy4wMTksMS44NiBjMS4wMjgsMC41ODIsMi4wMTIsMS4xODEsMi43OTcsMS45MjhjMC43OTQsMC43MzgsMS40MDEsMS42MTEsMS45MTcsMi41MDJjMC41MiwwLjg4NiwwLjkzNiwxLjc5NywxLjI3MSwyLjY4OCBjMC4zNDMsMC44ODMsMC41ODQsMS43NjYsMC43NjQsMi41ODJjMC4xOTEsMC44MDUsMC4yNzMsMS41OTIsMC4zMzgsMi4yNDJjMC4wNDQsMC4zMTQsMC4wNDQsMC42MzMsMC4wNTcsMC44OTggQzQ1LjQ5Niw0NC4wMTMsNDUuNTA0LDQ0LjI0LDQ1LjQ5NCw0NC40NDN6IE0yNC40MjksMjkuNjUyYy0yLjM2OSwxLjM5Ny01LjEyMiwyLjIxMy04LjA3MiwyLjIxMyBjLTguOCwwLTE1LjkzMy03LjEzMy0xNS45MzMtMTUuOTMzQzAuNDI0LDcuMTM0LDcuNTU4LDAsMTYuMzU3LDBzMTUuOTMyLDcuMTM0LDE1LjkzMiwxNS45MzNjMCwzLjM2OS0xLjA1MSw2LjQ5LTIuODM2LDkuMDYzIEMyOC4xMzksMjYuODkxLDI2LjQyMSwyOC40NzgsMjQuNDI5LDI5LjY1MnogTTIwLjU3MSwyMy40MjdjMS4wMzItMC41ODEsMS45MjctMS4zNzEsMi42MzgtMi4zMSBjMS4wOTMtMS40NDIsMS43NDktMy4yMzQsMS43NDktNS4xODNjMC00Ljc1LTMuODUtOC42MDEtOC42LTguNjAxcy04LjYwMSwzLjg1MS04LjYwMSw4LjYwMXMzLjg1MSw4LjYwMiw4LjYwMSw4LjYwMiBDMTcuODg5LDI0LjUzMywxOS4zMjUsMjQuMTI5LDIwLjU3MSwyMy40Mjd6Ii8+IDwvZz4gPC9nPgoNPC9zdmc+"
  // const arrowURI =
  // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNS44OTMiIGhlaWdodD0iMTUuODkzIiB2aWV3Qm94PSIwIDAgMTUuODkzIDE1Ljg5MyI+PHBhdGggZD0iTTkuMDIxIDEyLjI5NHYtMi4xMDdsLTYuODM5LS45MDVDMS4zOTggOS4xODQuODQ2IDguNDg2Ljk2MiA3LjcyN2MuMDktLjYxMi42MDMtMS4wOSAxLjIyLTEuMTY0bDYuODM5LS45MDVWMy42YzAtLjU4Ni43MzItLjg2OSAxLjE1Ni0uNDY0bDQuNTc2IDQuMzQ1YS42NDMuNjQzIDAgMCAxIDAgLjkxOGwtNC41NzYgNC4zNmMtLjQyNC40MDQtMS4xNTYuMTEtMS4xNTYtLjQ2NSIgZmlsbD0ibm9uZSIgc3Ryb2tlLW9wYWNpdHk9Ii4xNSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNzUiLz48cGF0aCBkPSJNOS4wMjEgMTIuMjk0di0yLjEwN2wtNi44MzktLjkwNUMxLjM5OCA5LjE4NC44NDYgOC40ODYuOTYyIDcuNzI3Yy4wOS0uNjEyLjYwMy0xLjA5IDEuMjItMS4xNjRsNi44MzktLjkwNVYzLjZjMC0uNTg2LjczMi0uODY5IDEuMTU2LS40NjRsNC41NzYgNC4zNDVhLjY0My42NDMgMCAwIDEgMCAuOTE4bC00LjU3NiA0LjM2Yy0uNDI0LjQwNC0xLjE1Ni4xMS0xLjE1Ni0uNDY1IiBmaWxsPSIjZmZmIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBkPSJNMCAxNS44OTJWMGgxNS44OTJ2MTUuODkyeiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==";

  // Objects
  let agent: Agent
  const mime = new Mime()

  /**Search Result Data */
  interface SearchResultData {
    posts: object[]
    actors: object[]
    cursor: string
    headers: object
  }

  type SearchResult =
    | "no search result yet"
    | "found nothing"
    | SearchResultData

  type ImageType = "avatar" | "banner" | "feed_thumbnail" | "feed_fullsize"

  // Special Functions

  /**
   * Parses the handle to be usable by the API
   * @param {string} handle - The handle to parse
   * @returns the handle without the @ symbol
   */
  const parseHandle = (handle: string): string => {
    return handle.replace("@", "")
  }

  /** Converts an image/video URL into a readable DataURI
   * @param {string} URL - The URL of the image/video
   */
  async function URLAsDataURI(URL: string) {
    const response = await Scratch.fetch(URL)
    const blob = await response.blob()
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onloadend = () => resolve(reader.result)
      reader.onerror = reject
      reader.readAsDataURL(blob)
    })
  }

  /** Converts a DataURI into an Unit8Array
   * @param {string} dataURI - The DataURI of the image/video
   */
  async function convertDataURIToUint8Array(dataURI: string) {
    let URI = dataURI
    if (dataURI.startsWith("http") || dataURI.startsWith("https")) {
      URI = Cast.toString(await URLAsDataURI(dataURI))
    }
    const byteString = atob(URI.split(",")[1])
    const arrayBuffer = new ArrayBuffer(byteString.length)
    const uint8Array = new Uint8Array(arrayBuffer)
    for (let i = 0; i < byteString.length; i++) {
      uint8Array[i] = byteString.charCodeAt(i)
    }
    return uint8Array
  }

  /**
   * Gets The File Size of An Image, to Respect the Upload Limit in BlueSky.
   */
  async function getFileSize(url: string) {
    const response = await fetch(url)
    const blob = await response.blob()
    if (blob.size > 100000000) {
      throw new Error("Error: File size is too big. It must be less than 1MB.")
    }
    console.log(`File size: ${blob.size} bytes`)
    return blob.size
  }

  const atUriConversions = {
    /** Converts a readable post url to an at:// uri. */
    postLinkToAtUri: async (postUrl: string) => {
      try {
        const url = new URL(postUrl)
        const pathSegments = url.pathname.split("/")
        // Validate URL structure
        if (
          pathSegments.length < 5 ||
          pathSegments[1] !== "profile" ||
          pathSegments[3] !== "post"
        ) {
          throw new Error("Invalid Bluesky post URL format.")
        }

        // Extract handle and post ID
        const handle = pathSegments[2]
        const postId = pathSegments[4]

        // Initialize the Bluesky agent

        // Resolve the handle to get the DID
        const handleResolution = await agent.resolveHandle({ handle: handle })
        const did = handleResolution.data.did

        // Construct the AT URI
        const atUri = `at://${did}/app.bsky.feed.post/${postId}`
        return atUri
      } catch (e) {
        throw new Error(`Conversion Failed: ${e}`)
      }
    },
    /** Converts a readable handle/profile url to an at:// uri. */
    handleToAtUri: async (handleUrl: string) => {
      try {
        let handle: string = Cast.toString(handleUrl)
        if (!handle.startsWith("@")) {
          if (handle.startsWith("http")) {
            const url = new URL(handleUrl)
            const pathSegments = url.pathname.split("/")
            handle = pathSegments[2]
          }
        } else {
          handle = handle.slice(1)
        }

        // Resolve the handle to get the DID
        const { data } = await agent.resolveHandle({ handle: handle })
        const did = data.did

        // Construct the AT URI
        return `at://${did}/`
      } catch (e) {
        throw new Error(`Conversion Failed: ${e}`)
      }
    },
    isValidAtUri: (atUri: string) => {
      return Cast.toBoolean(atUriPattern.test(atUri))
    },
    /** Converts an at:// uri to a readable post url. */
    atUritoPostLink: async (postAtUri: string) => {
      const match = postAtUri.match(atPostUriPattern)

      const uri = atUriConversions.isValidAtUri(postAtUri) ? match[1] : null
      const postId = match[2]

      const { data } = await agent.getProfile({ actor: uri })

      const handle = data.handle

      // Construct the Link
      return `https://bsky.app/profile/${handle}/post/${postId}`
    },
    /** Converts an at:// uri to a readable profile url. */
    atUritoProfileLink: async (profileAtUri: string) => {
      const did = atUriConversions.isValidAtUri(profileAtUri)
        ? atUriConversions.ExtractDID(profileAtUri)
        : null

      // Get the actor's data
      const { data } = await agent.getProfile({ actor: did })

      const handle = data.handle

      // Construct the Link
      return `https://bsky.app/profile/${handle}/`
    },
    /** Extracts the DID of an at:// uri. */
    ExtractDID: (atUri: string) => {
      const match = atUri.match(/(?!at:\/\/)(did:[^/]+)/)
      if (!match) {
        throw new Error("Error: Invalid at:// URI.")
      }
      return match ? match[0] : null
    },
    BlobReftoURL: (did: string, imgType: ImageType, blob: object) => {
      //@ts-expect-error data included in object
      const { data } = blob

      let mimeType: string = data.blob.mimeType

      mimeType = mimeType.replace(/.+\//, "")

      return `https://cdn.bsky.app/img/${imgType}/plain/${did}/${data.blob.ref.$link}@${mimeType}`
    },
    URLtoBlobRef: async (link: string) => {
      const url = new URL(link)

      const pathnames = url.pathname.split("/")

      if (pathnames.length < 5) {
        throw new Error("Invalid URL format")
      }

      const id = pathnames[4].replace(/@.*/, "")
      const type =
        mime.getType(pathnames[4].replace(/^[^@]*/, "")) ||
        "application/octet-stream"

      return {
        $type: "blob",
        ref: {
          $link: id
        },
        mimeType: type,
        size: await getFileSize(link)
      }
    }
  }

  // Utility Functions

  // Posting, Repling

  /** For posting on BlueSky */
  async function Post(
    post: string,
    useCurrentDate: boolean = true,
    date: string = "16-12-2024",
    embed = {}
  ) {
    try {
      let responseObj

      if (Object.keys(embed).length > 0) {
        responseObj = {
          text: post, // The Text
          embed: embed, // The Image Embed
          createdAt: useCurrentDate
            ? new Date().toISOString() // If the user is using the current date, then this will use the current date.
            : new Date(date).toISOString() // Otherwise, use the date the user assigned to it.
        }
      } else {
        responseObj = {
          text: post, // The Text
          createdAt: useCurrentDate
            ? new Date().toISOString() // If the user is using the current date, then this will use the current date.
            : new Date(date).toISOString() // Otherwise, use the date the user assigned to it.
        }
      }

      const response = await agent.post(responseObj)

      console.info(`Posted:${JSON.stringify(response)}`) // Logs the post info
      if (this.richText) {
        console.info(
          `Markdown Version of This Reply: ${ConvertRichTextToMarkdown(new RichText({ text: post }))}` // Logs the Markdown version of the post's text if rich text is enabled.
        )
      }
    } catch (error) {
      console.error(`Error Posting Post: ${error}`)
    }
  }
  async function Reply(
    post: string,
    useCurrentDate: boolean = true,
    date: string = "16-12-2024",
    threadRootPostArg,
    postReplyingToArg,
    embed: object = {}
  ) {
    try {
      const threadRootPost = threadRootPostArg
      const postReplyingTo = postReplyingToArg
      let responseObj

      if (Object.keys(embed).length > 0) {
        responseObj = {
          text: post, // The Text
          embed: embed,
          reply: {
            root: {
              // the reply thread data
              uri: threadRootPost.uri,
              cid: threadRootPost.cid
            },
            parent: {
              // the parent post data
              uri: postReplyingTo.uri,
              cid: postReplyingTo.cid
            }
          }, // The Image Embed
          createdAt: useCurrentDate
            ? new Date().toISOString() // If the user is using the current date, then this will use the current date.
            : new Date(date).toISOString() // Otherwise, use the date the user assigned to it.
        }
      } else {
        responseObj = {
          text: post, // The text (again)
          reply: {
            root: {
              // the reply thread data
              uri: threadRootPost.uri,
              cid: threadRootPost.cid
            },
            parent: {
              // the parent post data
              uri: postReplyingTo.uri,
              cid: postReplyingTo.cid
            }
          },
          createdAt: useCurrentDate
            ? new Date().toISOString()
            : new Date(date).toISOString()
        }
      }

      const response = await agent.post(responseObj)
      console.info(`Posted Reply: ${JSON.stringify(response)}`)
      if (this.richText) {
        console.info(
          `Markdown Version of This Reply: ${ConvertRichTextToMarkdown(new RichText({ text: post }))}`
        )
      }
    } catch (error) {
      console.error(`Error Posting Reply: ${error}`)
    }
  }

  /**
   * Uploads an image or video blob to the BlueSky servers using UploadBlob
   *
   */
  async function Upload(datauri: string, encoding: string = "image/png") {
    getFileSize(datauri) // Check the File Size of the Image

    const Unit8Array = await convertDataURIToUint8Array(datauri) // Get The Data of The URI

    const blob = await agent.uploadBlob(Unit8Array, {
      encoding: encoding
    })
    console.info(`Uploaded Blob: ${JSON.stringify(blob)}`)
    return blob
  }

  /**Finds hashtags inside text. (search params, post text, etc) */
  const FindTags = async (txt: string) => {
    const rt = new RichText({ text: txt })
    const tags: string[] = []
    await rt.detectFacets(agent)

    for (const segment of rt.segments()) {
      if (segment.isTag()) {
        tags.push(segment.tag?.tag)
      }
    }

    return tags
  }

  /** Cluster of functions to search posts and actors */

  const BskySearchFuncs = {
    SearchPosts: async (
      searchTerm: string,
      sortBy: "top" | "latest",
      cursor: string,
      limit: number,
      miscOptions: object = {}
    ) => {
      const response = await agent.app.bsky.feed.searchPosts({
        q: searchTerm,
        cursor: cursor,
        sort: sortBy,
        limit: limit,
        tag: await FindTags(searchTerm),
        ...miscOptions
      })
      return response
    },
    SearchActors: async (searchTerm: string, cursor: string, limit: number) => {
      const response = agent.searchActors({
        q: searchTerm,
        cursor: cursor,
        limit: limit
      })
      return response
    },
    Search: async (
      searchTerm: string,
      sortBy: "top" | "latest",
      cursor: string,
      limit: number
    ) => {
      const posts = await BskySearchFuncs.SearchPosts(
        searchTerm,
        sortBy,
        cursor,
        limit
      )
      const actors = await BskySearchFuncs.SearchActors(
        searchTerm,
        cursor,
        limit
      )

      const result: SearchResultData = {
        posts: posts.data.posts,
        actors: actors.data.actors,
        cursor: posts.data.cursor ?? actors.data.cursor,
        headers: posts.headers ?? actors.headers
      }

      return result
    }
  }

  /**Blocks an User on BlueSky using it's DID */
  async function BlockUser(
    blockingUserDid: string,
    session: OAuthSession,
    useCurrentDate: boolean,
    date: string
  ) {
    const data = await agent.app.bsky.graph.block.create(
      { repo: session.did },
      {
        subject: blockingUserDid,
        createdAt: useCurrentDate
          ? new Date().toISOString()
          : new Date(date).toISOString()
      }
    )

    console.info(`Blocked User With at:// URI: ${data.uri}`)
    console.info(data)
    return data
  }

  /**Unblocks an User on BlueSky using a block record DID */
  async function UnblockUser(blockedUserAtUri: string, session: OAuthSession) {
    const { rkey } = new AtUri(blockedUserAtUri)

    await agent.app.bsky.graph.block.delete({
      repo: session.did,
      rkey
    })
    console.info(`Unblocked User With at:// URI: ${blockedUserAtUri}`)
  }

  async function EditProfile(
    displayName: string,
    description: string,
    userImageType: string = "avatar",
    blob: { data: { blob: object } }
  ) {
    await agent.upsertProfile(existingProfile => {
      const existing = existingProfile ?? {}

      existing.displayName = displayName
      existing.description = description

      const { data } = blob

      if (Object.keys(blob).length !== 0) {
        existing[userImageType] = data.blob
      }
      console.log(existing)

      return existing
    })
  }

  /**
   * Convetrs BlueSky's rich text to Markdown
   *
   */
  function ConvertRichTextToMarkdown(rt: RichText) {
    // Converts rich text to Markdown
    let markdown = ""
    for (const segment of rt.segments()) {
      if (segment.isLink()) {
        markdown += `[${segment.text}](${segment.link?.uri})`
      } else if (segment.isMention()) {
        markdown += `[${segment.text}](https://bsky.app/profile/${segment.mention?.did})`
      } else {
        markdown += segment.text
      }
    }
    return markdown
  }

  /**Gets a List and It's Members.
   *
   * @param {boolean} fullListView: If enabled, paginates trough the entire list
   */
  async function GetBskyList(
    uri,
    cursorArg: string = "",
    limit: number = 6,
    fullListView?: boolean
  ) {
    let response: unknown

    if (!fullListView) {
      // Get List, as Normal
      response = await agent.app.bsky.graph.getList({
        list: uri,
        limit: limit,
        cursor: cursorArg
      })
    } else {
      // Use the Cursor argument
      let cursor: string | undefined = cursorArg
      // setup a members list
      let members: AppBskyGraphDefs.ListItemView[] = []

      // View the entire list
      do {
        const res = await agent.app.bsky.graph.getList({
          list: uri,
          limit: limit,
          cursor
        })
        cursor = res.data.cursor
        members = members.concat(res.data.items)
      } while (cursor)
      response = members
    }

    return response
  }

  class HamBskyAPI implements Scratch.Extension {
    runtime: VM.Runtime

    useCurrentDate: boolean
    date: string
    richText: boolean
    cursor: string
    limit: number
    sepCursorLimit: boolean

    OAuthClient: BrowserOAuthClient
    session: OAuthSession | null
    clientID: string
    injectMetadata: boolean
    clientMetadata: OAuthClientMetadataInput
    handleResolver: string

    searchResult: SearchResult
    sortSearch: "top" | "latest"
    lastBlockedUserURI: string | null

    showExtras: boolean

    constructor(runtime: VM.Runtime) {
      this.runtime = runtime

      this.useCurrentDate = true
      this.date = new Date().toISOString()
      this.richText = true
      this.cursor = null
      this.limit = null
      this.sepCursorLimit = true
      this.clientID =
        "https://hammouda101010.github.io/turbowarp-bsky-api/static/client-metadata.json"
      this.handleResolver = "https://bsky.social/"
      this.injectMetadata = true
      this.clientMetadata = {
        client_id:
          "https://hammouda101010.github.io/turbowarp-bsky-api/static/client-metadata.json",
        client_name: "TurboWarp/Penguinmod",
        client_uri: "https://hammouda101010.github.io/turbowarp-bsky-api",
        logo_uri:
          "https://hammouda101010.github.io/turbowarp-bsky-api/static/icons/favicon.ico",
        tos_uri: "https://scratch.mit.edu/terms_of_use",
        policy_uri: "https://turbowarp.org/privacy.html",
        redirect_uris: [
          "https://hammouda101010.github.io/turbowarp-bsky-api/redirect.html"
        ],
        scope: "atproto transition:generic",
        grant_types: ["authorization_code", "refresh_token"],
        response_types: ["code"],
        token_endpoint_auth_method: "none",
        application_type: "web",
        dpop_bound_access_tokens: true
      }

      this.searchResult = "no search result yet"
      this.sortSearch = "top"
      this.session = null
      this.lastBlockedUserURI = null

      this.showExtras = false
    }
    //@ts-expect-error
    getInfo() {
      return {
        id: "HamBskyAPI",
        name: "Bluesky API",
        color1: "#0484fc",
        color2: "#0970D1",
        menuIconURI: bskyMenuIcon,
        blockIconURI: bskyIcon,
        docsURI: "https://docs.bsky.app/", // I Don't Want to Make a Long Documentation about The Extension, So Have The Official BlueSky Docs for Now.
        blocks: [
          {
            blockType: Scratch.BlockType.BUTTON,
            func: "bskyDisclaimer",
            text: "Disclaimer (Please Read)"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyLoadOAuthClient",
            text: "load OAuth client"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyInitOAuthClient",
            text: "initialize OAuth session"
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyLogin",
            text: "login to bluesky API with OAuth using handle: [HANDLE]",
            arguments: {
              HANDLE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "@example.bsky.social"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyOAuthCallback",
            text: "callback this url query: [QUERY]",
            arguments: {
              QUERY: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "?iss=&state=&code="
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyLogout",
            text: "logout from bluesky API"
          },
          "---",
          {
            blockType: Scratch.BlockType.BOOLEAN,
            opcode: "bskyLoggedIn",
            text: "logged in to bluesky api?"
          },
          "---",
          {
            blockType: Scratch.BlockType.EVENT,
            opcode: "bskyWhenLoggedIn",
            text: "when logged in to bluesky",
            isEdgeActivated: false,
            shouldRestartExistingThreads: true
          },
          {
            blockType: Scratch.BlockType.EVENT,
            opcode: "bskyWhenLoggedOut",
            text: "when logged out from bluesky",
            isEdgeActivated: false,
            shouldRestartExistingThreads: true
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Creating Posts"
          },

          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyPost",
            text: "post [POST_ICON][POST] to bluesky with embed: [EMBED]",
            arguments: {
              POST_ICON: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: speechBubbleIcon
              },
              POST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "hello!"
              },
              EMBED: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyReply",
            text: "reply [POST_ICON][REPLY] to post with info:[INFO] embed: [EMBED]",
            arguments: {
              POST_ICON: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: speechBubbleIcon
              },
              REPLY: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "hello!"
              },
              INFO: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "use block below"
              },
              EMBED: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyReplyReporter",
            text: "parent post uri: [POST_URI] and cid: [POST_CID] with reply uri: [URI] and reply cid: [CID]",
            arguments: {
              POST_URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              },
              POST_CID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              },
              CID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "bafyreig2fjxi3rptqdgylg7e5hmjl6mcke7rn2b6cugzlqq3i4zu6rq52q"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyRepost",
            text: "repost post with uri [URI] and cid [CID]",
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              },
              CID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "bafyreig2fjxi3rptqdgylg7e5hmjl6mcke7rn2b6cugzlqq3i4zu6rq52q"
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyUnRepost",
            text: "remove post repost with uri [URI]",
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySetCurrentDate",
            text: "set date to [DATE]",
            hideFromPalette: this.useCurrentDate,
            arguments: {
              DATE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: new Date().toISOString()
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyUploadBlob",
            text: "upload image/video blob [DATAURI] with content-type [ENCODING]",
            blockIconURI: ImageIcon,
            outputShape: 3,
            arguments: {
              DATAURI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABrElEQVRIS+2VvUoDQRSGv+VQKQmKQj"
              },
              ENCODING: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyENCODING"
              }
            }
          },

          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyImgEmbed",
            text: "new  image embed with images [IMAGES]",
            blockIconURI: ImageIcon,
            arguments: {
              IMAGES: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  '["array", "use image embed reporter and/or an JSON extension"]'
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyImgEmbedReporter",
            text: "image embed with image [IMAGE] alt text [TEXT] width [WIDTH] and height [HEIGHT]",
            blockIconURI: ImageIcon,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "use upload blob reporter"
              },
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "this is the description of an embed"
              },
              WIDTH: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1000
              },
              HEIGHT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 500
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyWebCardEmbed",
            text: "new  website card embed with image [IMAGE] title [TITLE] description [DESCRIPTION] and link [LINK]",
            blockIconURI: ImageIcon,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "image blob"
              },
              TITLE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "title"
              },
              DESCRIPTION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "this is the description of an embed"
              },
              LINK: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "https://example.com"
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyQuotePost",
            text: "new quote post embed with uri [URI] and cid [CID] record",
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:u5cwb2mwiv2bfq53cjufe6yn/app.bsky.feed.post/3k43tv4rft22g"
              },
              CID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "bafyreig2fjxi3rptqdgylg7e5hmjl6mcke7rn2b6cugzlqq3i4zu6rq52q"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Viewing Feeds"
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetTimeline",
            text: "get my timeline [IMAGE] with cursor [CURSOR] and limit [LIMIT]",
            hideFromPalette: this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: TwoSpeechBubbleIcon
              },
              CURSOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              },
              LIMIT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 30
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetTimelineSep",
            text: "get my timeline [IMAGE]",
            outputShape: 3,
            hideFromPalette: !this.sepCursorLimit,
            disableMonitor: true,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: TwoSpeechBubbleIcon
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetFeed",
            text: "get feed [IMAGE] at [URI] with cursor [CURSOR] and limit [LIMIT]",
            hideFromPalette: this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: TwoSpeechBubbleIcon
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.generator/whats-hot"
              },
              CURSOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              },
              LIMIT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 30
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetFeedSep",
            text: "get feed [IMAGE] at [URI]",
            hideFromPalette: !this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: TwoSpeechBubbleIcon
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.generator/whats-hot"
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetFeedGenerator",
            text: "get feed generator [IMAGE] at [URI]",
            outputShape: 3,
            arguments: {
              IMAGE: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: TwoSpeechBubbleIcon
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.generator/whats-hot"
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetAuthorFeedSep",
            text: "get the author [URI]'s feed with filter [FILTER]",
            hideFromPalette: !this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "did:plc:z72i7hdynmk6r22z27h6tvur"
              },
              FILTER: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyAUTHOR_FEED_FILTERS"
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetAuthorFeed",
            text: "get the author [URI]'s feed with filter [FILTER] cursor [CURSOR] and limit [LIMIT]",
            hideFromPalette: this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "did:plc:z72i7hdynmk6r22z27h6tvur"
              },
              FILTER: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyAUTHOR_FEED_FILTERS"
              },
              CURSOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              },
              LIMIT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 50
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyMostRecentPostfromUser",
            text: "most recent post from [URI]",
            hideFromPalette: !this.sepCursorLimit,
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "did:plc:z72i7hdynmk6r22z27h6tvur"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySetCursor",
            text: "set feed cursor to [CURSOR]",
            hideFromPalette: !this.sepCursorLimit,
            arguments: {
              CURSOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySetLimit",
            text: "set feed searching limit to [LIMIT]",
            hideFromPalette: !this.sepCursorLimit,
            arguments: {
              LIMIT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 50
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyResetCursorLimit",
            text: "reset cursor and limit",
            hideFromPalette: !this.sepCursorLimit
          },
          "---",
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetPostThread",
            text: "get post thread at [URI] with depth [DEPTH] and parent height [HEIGHT]",
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              },
              DEPTH: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 6
              },
              HEIGHT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 80
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyGetPost",
            text: "get post at [URI]",
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Liking and Following"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyLike",
            text: "[ICON] like post at [URI] and cid [CID]",
            arguments: {
              ICON: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: HeartPlusIcon
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              },
              CID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "bafyreig2fjxi3rptqdgylg7e5hmjl6mcke7rn2b6cugzlqq3i4zu6rq52q"
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyUnLike",
            text: "[ICON] remove like from post at [URI]",
            arguments: {
              ICON: {
                type: Scratch.ArgumentType.IMAGE,
                dataURI: HeartBrokenIcon
              },
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyFollow",
            text: "follow user with DID/handle: [DID]",
            arguments: {
              DID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyUnFollow",
            text: "unfollow user with follow at:// uri record: [URI]",
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Viewing Profiles"
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyViewProfile",
            text: "get profile at [URI]",
            outputShape: 3,
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://..."
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyViewProfiles",
            text: "get profiles at [URIS]",
            outputShape: 3,
            arguments: {
              URIS: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "['did:plc:...', '...']"
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Editing Your Profile"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyEditProfile",
            text: "edit profile with new display name [DISPLAY_NAME] description [DESCRIPTION] and (optional) new [PROFILE_IMAGE_TYPE] image [IMAGE]",
            arguments: {
              DISPLAY_NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "new display name"
              },
              DESCRIPTION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "my description"
              },
              PROFILE_IMAGE_TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyPROFILE_IMAGE_TYPE"
              },
              IMAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "use upload blob reporter"
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Blocking and Muting"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyBlockUser",
            text: "block user with DID [DID]",
            arguments: {
              DID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "ihateu.bsky.social"
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyLastBlockedUser",
            text: "last blocked user DID",
            outputShape: 3
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyUnblockUser",
            text: "unblock user with block at:// uri record [URI]",
            arguments: {
              URI: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyMuteUser",
            text: "mute user with DID [DID]",
            arguments: {
              DID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyUnmuteUser",
            text: "unmute user with DID [DID]",
            arguments: {
              DID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Searching Posts and Profiles"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySearch",
            text: "search posts/profiles with search term [TERM] cursor [CURSOR] and limit [LIMIT]",
            hideFromPalette: this.sepCursorLimit,
            blockIconURI: SearchingLensIcon,
            arguments: {
              TERM: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i love pizza"
              },
              CURSOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ""
              },
              LIMIT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 69
              }
            }
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySearchSep",
            text: "search posts/profiles with search term [TERM]",
            hideFromPalette: !this.sepCursorLimit,
            blockIconURI: SearchingLensIcon,
            arguments: {
              TERM: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i love pizza"
              }
            }
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskySearchResult",
            text: "search result",
            disableMonitor: false
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySearchSort",
            text: "sort post search results by [POST_SORT]",
            hideFromPalette: !this.sepCursorLimit,
            blockIconURI: SearchingLensIcon,
            arguments: {
              POST_SORT: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskySEARCH_SORT_BY"
              }
            }
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "OAuth Configuration"
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskySetOAuthMetadata",
            text: "set [KEY] OAuth metadata to [VALUE]"
          },
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Extras"
          },

          {
            blockType: Scratch.BlockType.BUTTON,
            func: "bskyShowExtras",
            text: "Show Extras",
            hideFromPalette: this.showExtras
          },
          {
            blockType: Scratch.BlockType.BUTTON,
            func: "bskyHideExtras",
            text: "Hide Extras",
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyProfileLinkToAtUri",
            text: "convert profile URL/handle [URL] to at:// uri",
            outputShape: 3,
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "https://bsky.app/profile/example.bsky.social/"
              }
            },
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyPostLinkToAtUri",
            text: "convert post URL [URL] to at:// uri",
            outputShape: 3,
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "https://bsky.app/profile/example.bsky.social/post/3lez77bnyhs2w"
              }
            },
            hideFromPalette: !this.showExtras
          },
          "---",
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyAtUriToPostLink",
            text: "convert at:// uri [URL] to post URL",
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "at://did:plc:6loexbxe5rv4knai6j57obtn/app.bsky.feed.post/3lez77bnyhs2w"
              }
            },
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyAtUriToProfileLink",
            text: "convert at:// uri [URL] to profile URL",
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://did:plc:6loexbxe5rv4knai6j57obtn"
              }
            },
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyExtractDID",
            text: "extract DID from at:// uri [URL]",
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://did:plc:6loexbxe5rv4knai6j57obtn"
              }
            },
            hideFromPalette: !this.showExtras
          },
          "---",
          {
            blockType: Scratch.BlockType.BOOLEAN,
            opcode: "bskyIsAtUri",
            text: "is [URL] a valid at:// uri? ",
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "at://did:plc:6loexbxe5rv4knai6j57obtn"
              }
            },
            hideFromPalette: !this.showExtras
          },
          "---",
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyBlobReftoURL",
            text: "convert blob reference [BLOB] to URL with DID [DID] and [IMAGE_TYPE] image type ",
            arguments: {
              BLOB: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "blob ref"
              },
              DID: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "did:plc:6loexbxe5rv4knai6j57obtn"
              },
              IMAGE_TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyIMAGE_TYPE"
              }
            },
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyURLtoBlobRef",
            text: "convert bluesky image URL [URL] to blob reference",
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "url"
              }
            },
            hideFromPalette: !this.showExtras,
            outputShape: 3
          },
          "---",
          {
            blockType: Scratch.BlockType.LABEL,
            text: "Advanced",
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyLexicon",
            text: "use bluesky lexicon [LEXICON] with inputs [INPUTS]",
            arguments: {
              LEXICON: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "app.bsky.feed"
              },
              INPUTS: {
                type: null
              }
            },
            hideFromPalette: !this.showExtras,

            outputShape: 3
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyLexiconReporter",
            text: "use bluesky lexicon [LEXICON] with inputs [INPUTS]",
            arguments: {
              LEXICON: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "app.bsky.feed"
              },
              INPUTS: {
                type: null
              }
            },
            hideFromPalette: !this.showExtras
          },
          {
            blockType: Scratch.BlockType.REPORTER,
            opcode: "bskyLexiconInputs",
            text: "lexicon inputs",
            arguments: {},
            hideFromPalette: !this.showExtras,
            disableMonitor: true,

            mutator: "cst_extendable",
            extensions: ["cst_extendable_string"],

            outputShape: 3
          },
          "---",
          {
            blockType: Scratch.BlockType.COMMAND,
            opcode: "bskyOptions",
            text: "set [OPTION] to [ONOFF]",
            hideFromPalette: !this.showExtras,
            arguments: {
              OPTION: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyOPTIONS"
              },
              ONOFF: {
                type: Scratch.ArgumentType.STRING,
                menu: "bskyONOFF"
              }
            }
          }
        ],
        menus: {
          bskyOPTIONS: {
            acceptReporters: true,
            items: [
              { text: "rich text", value: "richText" },
              { text: "use current date", value: "useCurrentDate" },
              {
                text: "cursor and limit as seperate blocks",
                value: "sepCursorLimit"
              }
            ]
          },
          bskyONOFF: {
            acceptReporters: false,
            items: [
              { text: "on", value: "true" },
              { text: "off", value: "false" }
            ]
          },
          bskySEARCH_SORT_BY: {
            acceptReporters: false,
            items: [
              { text: Scratch.translate("top posts"), value: "top" },
              { text: Scratch.translate("latest posts"), value: "latest" }
            ]
          },
          bskyENCODING: {
            acceptReporters: true,
            items: [
              { text: "png", value: "image/png" },
              { text: "jpg", value: "image/jpeg" },
              { text: "gif", value: "image/gif" },
              { text: "webp", value: "image/webp" },
              { text: "svg", value: "image/svg+xml" },
              { text: "tiff", value: "image/tiff" },
              { text: "bmp", value: "image/bmp" }
            ]
          },
          bskyAUTHOR_FEED_FILTERS: {
            acceptReporters: true,
            items: [
              { text: "posts and replies", value: "posts_with_replies" },
              { text: "posts only", value: "posts_no_replies" },
              { text: "posts with media", value: "posts_with_media" },
              {
                text: "posts and author threads",
                value: "posts_and_author_threads"
              }
            ]
          },
          bskyPROFILE_IMAGE_TYPE: {
            acceptReporters: true,
            items: ["avatar", "banner"]
          },
          bskyIMAGE_TYPE: {
            acceptReporters: true,
            items: [
              "avatar",
              "banner",
              { text: "embed thumbnail", value: "feed_thumbnail" },
              { text: "fullsize image", value: "feed_fullsize" }
            ]
          }
        }
      }
    }

    /* ---- BUTTONS----*/
    bskyDisclaimer() {
      alert(
        `DISCLAIMER:

          Rules to Follow:
          1. Follow BlueSky's Terms of Service: https://bsky.social/about/support/tos
          2. Avoid Copyright Infringements: https://bsky.social/about/support/copyright
          3. Respect Community Guidelines: https://bsky.social/about/support/community-guidelines
          4. Do Not Use This Extension for Malicious Purposes, such as Spam Bots, Scams, or Hacking other Accounts.
          
          Note: This Extension Pairs Well With JSON Extensions.`
      )
    }
    bskyShowExtras() {
      this.showExtras = !this.showExtras
      vm.extensionManager.refreshBlocks()
    }
    bskyHideExtras() {
      this.showExtras = !this.showExtras
      vm.extensionManager.refreshBlocks()
    }
    /* ---- BUTTONS----*/

    async LoadOAuthClient() {
      if (this.injectMetadata) {
        // Hardcode the metadata if this.injectMetadata is true
        this.OAuthClient = new BrowserOAuthClient({
          clientMetadata: this.clientMetadata,
          handleResolver: this.handleResolver,
          responseMode: "query"
        })
      } else {
        // Otherwise load it from static file hosting
        this.OAuthClient = await BrowserOAuthClient.load({
          clientId: this.clientID,
          handleResolver: this.handleResolver,
          responseMode: "query"
        })
      }

      console.log(this.OAuthClient)

      console.log("Loaded OAuth Client")
    }

    async bskyLoadOAuthClient() {
      await this.LoadOAuthClient()
    }

    async bskyInitOAuthClient() {
      const result = await this.OAuthClient.init()

      console.log(result ?? "No Result")

      if (result) {
        //@ts-expect-error
        const { session, state } = result

        this.session = session

        if (state !== null) {
          console.log(`Logged in With DID: ${session.sub} (state: ${state})`)
        } else {
          console.log(`${session.sub}'s session was restored`)
        }
      }
      this.session = result?.session
    }

    async bskyLogin(args) {
      if (!this.session) {
        const handle = parseHandle(args.HANDLE)
        if (!handle) throw new Error("No Handle Found")
        this.session = await this.OAuthClient.signIn(handle, {
          scope: "atproto transition:generic",
          display: "popup",
          ui_locales: "fr-CA fr en",
          signal: new AbortController().signal
        })

        agent = new Agent(this.session)
        document.dispatchEvent(BskyLoginEvent)
      } else {
        agent = new Agent(this.session)
        document.dispatchEvent(BskyLoginEvent)
      }
    }
    async bskyOAuthCallback(args) {
      const result = await this.OAuthClient.callback(
        new URLSearchParams(args.QUERY)
      )

      this.session = result.session
    }

    async bskyLogout(): Promise<void> {
      await this.session.signOut()

      console.info(`Logged Out from API.`)

      document.dispatchEvent(BskyLogoutEvent)
    }
    bskyLoggedIn() {
      return Cast.toBoolean(this.session)
    }

    async bskyPost(args): Promise<void> {
      if (!this.richText) {
        const rt = new RichText({ text: args.POST })

        await rt.detectFacets(agent)

        if (rt.facets && rt.facets.length > 0) {
          throw new Error("Error: You Can't Use Rich Text If It's Disabled.")
        }
        if (args.EMBED) {
          const embed = JSON.parse(args.EMBED)
          await Post(args.POST, this.useCurrentDate, this.date, embed)
        } else {
          await Post(args.POST, this.useCurrentDate, this.date)
        }
      } else {
        if (args.EMBED) {
          const embed = JSON.parse(args.EMBED)
          await Post(args.POST, this.useCurrentDate, this.date, embed)
        } else {
          await Post(args.POST, this.useCurrentDate, this.date)
        }
      }
    }
    async bskyReply(args): Promise<void> {
      const replyData = JSON.parse(args.INFO)
      if (!this.richText) {
        const rt = new RichText({ text: args.REPLY })

        await rt.detectFacets(agent)

        if (rt.facets && rt.facets.length > 0) {
          throw new Error("Error: You Can't Use Rich Text If It's Disabled.")
        }
        if (args.EMBED) {
          const embed = JSON.parse(args.EMBED)
          await Reply(
            args.REPLY,
            this.useCurrentDate,
            this.date,
            replyData.threadRootPost,
            replyData.postReplyingto,
            embed
          )
        } else {
          await Reply(
            args.REPLY,
            this.useCurrentDate,
            this.date,
            replyData.threadRootPost,
            replyData.postReplyingto
          )
        }
      } else {
        if (args.EMBED) {
          const embed = JSON.parse(args.EMBED)
          await Reply(
            args.REPLY,
            this.useCurrentDate,
            this.date,
            replyData.threadRootPost,
            replyData.postReplyingto,
            embed
          )
        } else {
          await Reply(
            args.REPLY,
            this.useCurrentDate,
            this.date,
            replyData.threadRootPost,
            replyData.postReplyingto
          )
        }
      }
    }
    bskySetCurrentDate(args) {
      this.date = args.DATE
    }
    async bskyUploadBlob(args) {
      try {
        const blob = await Upload(args.DATAURI, args.ENCODING)
        console.log(blob)

        return JSON.stringify(blob)
      } catch (error) {
        throw new Error(`Error Uploading Blob: ${error}`)
      }
    }
    bskyWebCardEmbed(args) {
      const { data } = JSON.parse(args.IMAGE)
      return JSON.stringify({
        $type: "app.bsky.embed.external",
        external: {
          uri: args.LINK,
          title: args.TITLE,
          description: args.DESCRIPTION,
          thumb: data.blob
        }
      })
    }
    bskyImgEmbed(args) {
      return JSON.stringify({
        $type: "app.bsky.embed.images",
        images: Array.isArray(args.IMAGES) // The list of images
          ? JSON.parse(args.IMAGES)
          : [JSON.parse(args.IMAGES)]
      })
    }

    bskyImgEmbedReporter(args) {
      // Use this reporter for the embed block above.
      const { data } = JSON.parse(args.IMAGE)
      return JSON.stringify({
        alt: args.TEXT, // the alt text
        image: data.blob,
        aspectRatio: {
          // a hint to clients
          width: args.WIDTH,
          height: args.HEIGHT
        }
      })
    }
    bskyQuotePost(args) {
      return JSON.stringify({
        $type: "app.bsky.embed.record",
        record: {
          uri: args.URI,
          cid: args.CID
        }
      })
    }
    bskyReplyReporter(args): string {
      // Use this reporter for the reply block.
      return JSON.stringify({
        threadRootPost: {
          uri: args.POST_URI,
          cid: args.POST_CID
        },
        postReplyingto: {
          uri: args.POST_URI,
          cid: args.POST_CID
        }
      })
    }

    // Viewing Feeds
    async bskyGetTimeline(args) {
      const { data } = await agent.getTimeline({
        cursor: args.CURSOR,
        limit: args.LIMIT
      })

      return JSON.stringify(data)
    }
    async bskyGetTimelineSep() {
      const { data } = await agent.getTimeline({
        cursor: this.cursor ?? "",
        limit: this.limit ?? 50
      })

      return JSON.stringify(data)
    }

    // Getting a Feed
    async bskyGetFeed(args) {
      const { data } = await agent.app.bsky.feed.getFeed({
        feed: args.URI,
        cursor: args.CURSOR,
        limit: args.LIMIT
      })

      return JSON.stringify(data)
    }
    async bskyGetFeedSep(args) {
      const { data } = await agent.app.bsky.feed.getFeed({
        feed: args.URI,
        cursor: this.cursor ?? "",
        limit: this.limit ?? 50
      })

      return JSON.stringify(data)
    }

    // Getting a Feed Generator
    async bskyGetFeedGenerator(args) {
      const { data } = await agent.app.bsky.feed.getFeedGenerator({
        feed: args.URI
      })

      return JSON.stringify(data)
    }

    // Getting an User's Posts
    async bskyGetAuthorFeed(args) {
      const { data } = await agent.getAuthorFeed({
        actor: parseHandle(args.URI),
        filter: args.FILTER,
        cursor: args.CURSOR,
        limit: args.LIMIT ?? 50
      })

      return JSON.stringify(data)
    }
    async bskyGetAuthorFeedSep(args) {
      const { data } = await agent.getAuthorFeed({
        actor: parseHandle(args.URI),
        filter: args.FILTER,
        cursor: this.cursor ?? "",
        limit: this.limit ?? 50
      })

      return JSON.stringify(data)
    }
    async bskyMostRecentPostfromUser(args) {
      const { data } = await agent.getAuthorFeed({
        actor: args.URI,
        filter: args.FILTER,
        cursor: "",
        limit: 1
      })

      const recentPost = data.feed[0]

      return JSON.stringify(recentPost)
    }

    bskySetCursor(args) {
      this.cursor = args.CURSOR
    }
    bskySetLimit(args) {
      this.limit = args.LIMIT
    }

    bskyResetCursorLimit() {
      this.cursor = null
      this.limit = null
    }

    async bskyGetPostThread(args) {
      const res = await agent.getPostThread({
        uri: args.URI,
        depth: args.DEPTH,
        parentHeight: args.HEIGHT
      })

      const { thread } = res.data

      return JSON.stringify(thread)
    }
    async bskyGetPost(args) {
      const res = await agent.getPostThread({
        uri: args.URI,
        depth: 1,
        parentHeight: 1
      })
      const { thread } = res.data

      return JSON.stringify(thread)
    }

    async bskyLike(args) {
      const res = await agent.like(args.URI, args.CID)

      console.info(`Liked Post: ${JSON.stringify(res)}`)
    }
    async bskyRepost(args) {
      const uri = await agent.repost(args.URI, args.CID)

      console.info(`Reposted Post: ${JSON.stringify(uri)}`)
    }
    async bskyFollow(args) {
      const { uri } = await agent.follow(parseHandle(args.DID))

      console.info(`Followed User: ${JSON.stringify(uri)}`)
    }

    async bskyUnLike(args) {
      const res = await agent.deleteLike(args.URI)

      console.info(`UnLiked Post: ${JSON.stringify(res)}`)
    }

    async bskyUnRepost(args) {
      try{

      const uri = await agent.deleteRepost(args.URI)

      console.info(`Unreposted Post: ${JSON.stringify(uri)}`)
      } catch {
        console.error("Error: Couldn't find Repost URI")
      }
    }

    async bskyUnFollow(args) {
      const response = await agent.follow(parseHandle(args.DID))

      console.info(`Unfollowed User: ${JSON.stringify(response)}`)
    }

    async bskyViewProfile(args) {
      const { data } = await agent.getProfile({ actor: parseHandle(args.URI) })

      return JSON.stringify(data)
    }
    async bskyViewProfiles(args) {
      const { data } = await agent.getProfiles({ actors: JSON.parse(args.URI) })

      return JSON.stringify(data)
    }

    async bskyEditProfile(args) {
      await EditProfile(
        args.DISPLAY_NAME,
        args.DESCRIPTION,
        args.PROFILE_IMAGE_TYPE,
        args.IMAGE
      )
    }

    async bskyBlockUser(args) {
      const { uri } = await BlockUser(
        parseHandle(args.DID),
        this.session,
        this.useCurrentDate,
        this.date
      )
      this.lastBlockedUserURI = Cast.toString(uri)
    }
    bskyLastBlockedUser() {
      return this.lastBlockedUserURI ?? "no data found"
    }
    async bskyUnblockUser(args) {
      await UnblockUser(args.URI, this.session)
    }

    async bskyMuteUser(args) {
      const response = await agent.mute(parseHandle(args.DID))

      console.info(
        `Muted User: ${await atUriConversions.atUritoProfileLink(`at://${args.DID}`)}`
      )
      console.log(response)
    }
    async bskyUnmuteUser(args) {
      const response = await agent.unmute(parseHandle(args.DID))

      console.info(
        `Unmuted User: ${await atUriConversions.atUritoProfileLink(`at://${args.DID}`)}`
      )
      console.log(response)
    }

    async bskySearch(args) {
      const response = await BskySearchFuncs.Search(
        args.TERM,
        this.sortSearch,
        args.CURSOR,
        args.LIMIT
      )
      const posts = response.posts
      const actors = response.actors

      this.searchResult =
        posts.length !== 0 && actors.length !== 0 ? response : "found nothing"
    }
    bskySearchSort(args) {
      this.sortSearch = args.POST_SORT
    }

    async bskySearchSep(args) {
      const response = await BskySearchFuncs.Search(
        args.TERM,
        this.sortSearch,
        this.cursor ?? "",
        this.limit ?? 50
      )
      const posts = response.posts
      const actors = response.actors

      this.searchResult =
        posts.length !== 0 && actors.length !== 0 ? response : "found nothing"
    }

    bskySearchResult() {
      return typeof this.searchResult === "object" && this.searchResult !== null
        ? JSON.stringify(this.searchResult)
        : this.searchResult
    }

    async bskyPostLinkToAtUri(args): Promise<string> {
      return await atUriConversions.postLinkToAtUri(args.URL)
    }
    async bskyProfileLinkToAtUri(args): Promise<string> {
      return await atUriConversions.handleToAtUri(args.URL)
    }
    async bskyAtUriToPostLink(args): Promise<string> {
      return await atUriConversions.atUritoPostLink(args.URL)
    }
    async bskyAtUriToProfileLink(args): Promise<string> {
      return await atUriConversions.atUritoProfileLink(args.URL)
    }
    bskyIsAtUri(args): boolean {
      return Cast.toBoolean(atUriConversions.isValidAtUri(args.URL))
    }
    bskyExtractDID(args): string {
      return Cast.toString(atUriConversions.ExtractDID(args.URL))
    }

    bskyBlobReftoURL(args) {
      return atUriConversions.BlobReftoURL(args.DID, args.IMAGE_TYPE, args.BLOB)
    }
    async bskyURLtoBlobRef(args) {
      return JSON.stringify(await atUriConversions.URLtoBlobRef(args.URL))
    }

    async bskyLexicon(args) {
      await agent.call(args.LEXICON, args.INPUTS)
    }
    async bskyLexiconReporter(args) {
      const response = await agent.call(args.LEXICON, args.INPUTS)

      return JSON.stringify(response)
    }

    bskyLexiconInputs(args) {
      const prefix = "ARG"
      const params: object = {}
      for (let i = 0; prefix + i in args; i++) {
        const arg: object = JSON.parse(`{${args[prefix + i]}}`)
        if (Object.keys(arg).length > 1){
          throw new Error("Can't have more than 1 key for each argument")
        }
        Object.assign(params, arg)
      }
      return JSON.stringify(params)
    }

    bskyOptions(args) {
      switch (args.OPTION) {
        case "richText":
          this.richText = Cast.toBoolean(args.ONOFF)
          break
        case "useCurrentDate":
          this.useCurrentDate = Cast.toBoolean(args.ONOFF)
          vm.extensionManager.refreshBlocks()
          break
        case "sepCursorLimit":
          this.sepCursorLimit = Cast.toBoolean(args.ONOFF)
          vm.extensionManager.refreshBlocks()
          break
        default:
          throw new Error("Error: This option doesn't exist.")
      }
    }
    // Utilities
    getCurrentMutation(args, util) {
      return (
        args.mutation ||
        util.target.blocks.getBlock(util.thread.peekStack())?.mutation ||
        runtime.flyoutBlocks.getBlock(util.thread.peekStack())?.mutation
      )
    }
  }

  // Event Blocks
  document.addEventListener("bskyLogin", () => {
    runtime.startHats("HamBskyAPI_bskyWhenLoggedIn")
  })
  document.addEventListener("bskyLogout", () => {
    runtime.startHats("HamBskyAPI_bskyWhenLoggedOut")
  })

  // Extendable Blocks Patch (Credits to CST1229)

  /* eslint-disable */

  // @ts-expect-error ignore
  const cbfsb = runtime._convertBlockForScratchBlocks.bind(runtime)
  // @ts-expect-error ignore
  runtime._convertBlockForScratchBlocks = function (blockInfo, categoryInfo) {
    const res = cbfsb(blockInfo, categoryInfo)
    if (blockInfo.mutator) {
      res.json.mutator = blockInfo.mutator
    }
    return res
  }

  function patchSB() {
    const ScratchBlocks = window?.ScratchBlocks
    if (!ScratchBlocks) return

    Scratch.vm.removeListener("EXTENSION_ADDED", patchSB)
    Scratch.vm.removeListener("BLOCKSINFO_UPDATE", patchSB)

    const leftArrowIcon = `data:image/svg+xml;base64,PHN2ZyBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDEwIDEzIiB0cmFuc2Zvcm09InNjYWxlKC0xLCAxKSI+PHBhdGggZD0iTTMuNjUuMTQ1YTIuNDEgMi40MSAwIDAgMSAxLjcyLjcxbDMuOTIgMy45MmEyLjQ1IDIuNDUgMCAwIDEgMCAzLjQ1bC0zLjkyIDMuOTFhMi40MiAyLjQyIDAgMCAxLTEuNzIuNzIgMi40OCAyLjQ4IDAgMCAxLTEuNzMtLjcxYy0uMjQtLjI5LS43MS0uNzItLjcxLTUuNjUgMC00LjkzLjQ2LTUuMzkuNzEtNS42NGEyLjQ0IDIuNDQgMCAwIDEgMS43My0uNzF6IiBmaWxsPSIjMjMxZjIwIiBvcGFjaXR5PSIuMSIvPjxwYXRoIGQ9Ik04Ljk4NSA2LjUxYTEuNDMgMS40MyAwIDAgMS0uNDIgMWwtMy45MiAzLjk0YTEuNDQgMS40NCAwIDAgMS0yIDBjLS41Ni0uNTYtLjU2LTkuMzEgMC05Ljg3YTEuNDQgMS40NCAwIDAgMSAyIDBsMy45MiAzLjkyYTEuNDMgMS40MyAwIDAgMSAuNDIgMS4wMXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=`
    const rightArrowIcon = `data:image/svg+xml;base64,PHN2ZyBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDEwIDEzIj48cGF0aCBkPSJNMy42NS4xNDVhMi40MSAyLjQxIDAgMCAxIDEuNzIuNzFsMy45MiAzLjkyYTIuNDUgMi40NSAwIDAgMSAwIDMuNDVsLTMuOTIgMy45MWEyLjQyIDIuNDIgMCAwIDEtMS43Mi43MiAyLjQ4IDIuNDggMCAwIDEtMS43My0uNzFjLS4yNC0uMjktLjcxLS43Mi0uNzEtNS42NSAwLTQuOTMuNDYtNS4zOS43MS01LjY0YTIuNDQgMi40NCAwIDAgMSAxLjczLS43MXoiIGZpbGw9IiMyMzFmMjAiIG9wYWNpdHk9Ii4xIi8+PHBhdGggZD0iTTguOTg1IDYuNTFhMS40MyAxLjQzIDAgMCAxLS40MiAxbC0zLjkyIDMuOTRhMS40NCAxLjQ0IDAgMCAxLTIgMGMtLjU2LS41Ni0uNTYtOS4zMSAwLTkuODdhMS40NCAxLjQ0IDAgMCAxIDIgMGwzLjkyIDMuOTJhMS40MyAxLjQzIDAgMCAxIC40MiAxLjAxeiIgZmlsbD0iI2ZmZiIvPjwvc3ZnPg==`
    const arrowWidth = 16
    const arrowHeight = 32

    class FieldImageButton extends ScratchBlocks.FieldImage {
      constructor(src, width, height, callback, opt_alt, flip_rtl, noPadding) {
        super(src, width, height, opt_alt, flip_rtl)
        this._callback = callback.bind(this)
        this.noPadding = noPadding
      }
      init() {
        if (this.fieldGroup_) {
          // Image has already been initialized once.
          return
        }
        super.init()
        this.mouseDownWrapper_ = ScratchBlocks.bindEventWithChecks_(
          this.getSvgRoot(),
          "mousedown",
          this,
          this.onMouseDown_
        )
        this.getSvgRoot().style.cursor = "pointer"
      }
      showEditor_() {
        if (this._callback) {
          this._callback()
        }
      }
      getSize() {
        if (!this.size_.width) {
          this.render_()
        }
        if (!this.noPadding) return this.size_
        return new this.size_.constructor(
          Math.max(1, this.size_.width - ScratchBlocks.BlockSvg.SEP_SPACE_X),
          this.size_.height
        )
      }
      EDITABLE = true
    }

    // heavily based on scratch-blocks' procedures code
    // https://github.com/TurboWarp/scratch-blocks
    ScratchBlocks.Extensions.registerMutator(
      "cst_extendable",
      {
        domToMutation(xmlElement) {
          this.inputCount = Math.floor(
            Number(xmlElement.getAttribute("inputcount"))
          )
          this.inputCount = Math.min(
            Math.max(this.minInputs, this.inputCount),
            this.maxInputs
          )
          if (isNaN(this.inputCount) || !Number.isFinite(this.inputCount))
            this.inputCount = this.minInputs
          this.prevInputCount = this.inputCount
          // HACK: fixes alt+drag duplicate not adding blocks inside
          this.updateDisplay_(true)
        },
        mutationToDom() {
          const container = document.createElement("mutation")
          container.setAttribute("inputcount", this.inputCount.toString())
          return container
        },

        isExtendableInput(input) {
          return (
            input.name.startsWith("ARROW_") ||
            this.extendableDefs.some(def => input.name.startsWith(def.id)) ||
            this.extendableDefsStart.some(def =>
              input.name.startsWith(def.id)
            ) ||
            this.extendableDefsEnd.some(def => input.name.startsWith(def.id))
          )
        },

        // Disconnects all blocks in extendable inputs and returns them.
        disconnectOldBlocks_() {
          const connectionMap = {}
          const hasEndBlocks = this.extendableDefsEnd.length > 0
          const hasStartBlocks = this.extendableDefsStart.length > 0
          const prevEndIndex =
            this.prevInputCount + (this.extendableDefsStart.length > 0)

          // Reattach end blocks when inputs are added/removed
          const reattachMap = Object.create(null)
          if (hasEndBlocks) {
            for (const def of this.extendableDefsEnd) {
              const input = this.getInput(
                this.getExtendableInput(def.id, prevEndIndex)
              )
              if (input && input.connection) {
                reattachMap[input.name] = def.id
              }
            }
          }

          for (const input of this.inputList) {
            if (input.connection && this.isExtendableInput(input)) {
              const target = input.connection.targetBlock()
              const saveInfo = {
                shadow: input.connection.getShadowDom(),
                block: target
              }

              let name = input.name
              if (reattachMap[name]) {
                name = this.getExtendableInput(
                  reattachMap[name],
                  this.inputCount + hasStartBlocks
                )
                if (connectionMap[name]) {
                  connectionMap["$UNUSED" + name] = connectionMap[name]
                  delete connectionMap[name]
                }
              }

              if (connectionMap[name]) {
                connectionMap["$UNUSED" + name] = saveInfo
              } else {
                connectionMap[name] = saveInfo
              }

              // Remove the shadow DOM, then disconnect the block.	Otherwise a shadow
              // block will respawn instantly, and we'd have to remove it when we remove
              // the input.
              input.connection.setShadowDom(null)
              if (target) {
                input.connection.disconnect()
              }
            }
          }
          return connectionMap
        },

        removeAllInputs_() {
          this.inputList = this.inputList.filter(input => {
            if (
              this.isExtendableInput(input) ||
              (input.type === ScratchBlocks.DUMMY_INPUT && this.clearLabels)
            ) {
              input.dispose()
              return false
            }
            return true
          })
        },

        // Creates a shadow input for an extendable definition.
        attachShadow_(input, def) {
          if (!def.shadowType) return
          ScratchBlocks.Events.disable()
          let newBlock
          try {
            newBlock = this.workspace.newBlock(def.shadowType)
            newBlock.setFieldValue(def.shadowDefault, def.shadowField)
            newBlock.setShadow(true)
            if (!this.isInsertionMarker()) {
              newBlock.initSvg()
              newBlock.render(false)
            }
          } finally {
            ScratchBlocks.Events.enable()
          }
          if (ScratchBlocks.Events.isEnabled()) {
            ScratchBlocks.Events.fire(
              new ScratchBlocks.Events.BlockCreate(newBlock)
            )
          }
          if (newBlock.outputConnection)
            newBlock.outputConnection.connect(input.connection)
          else newBlock.previousConnection.connect(input.connection)
        },
        buildShadowDom_(def) {
          const shadowDom = document.createElement("shadow")
          shadowDom.setAttribute("type", def.shadowType)
          const fieldDom = document.createElement("field", null)
          fieldDom.setAttribute("name", def.shadowField)
          shadowDom.appendChild(fieldDom)
          return shadowDom
        },

        // Populates an argument.
        // Puts existing blocks back in or creates new ones.
        populateArgument_(connectionMap, id, input, def) {
          let oldBlock = null
          let oldShadow = null

          if (connectionMap && id in connectionMap) {
            const saveInfo = connectionMap[id]
            oldBlock = saveInfo["block"]
            oldShadow = saveInfo["shadow"]
          }

          if (connectionMap && oldBlock) {
            // Reattach the old block and shadow DOM.
            connectionMap[id] = null
            if (oldBlock.outputConnection)
              oldBlock.outputConnection.connect(input.connection)
            else oldBlock.previousConnection.connect(input.connection)
            if (def.shadowType) {
              const shadowDom = oldShadow || this.buildShadowDom_(def)
              input.connection.setShadowDom(shadowDom)
            }
          } else {
            this.attachShadow_(input, def)
          }
        },

        // Removes unused inputs from the VM
        cleanInputs() {
          const target = Scratch.vm.editingTarget
          if (!target) return
          const blocks = this.isInFlyout
            ? Scratch.vm.runtime.flyoutBlocks
            : target.blocks
          const vmBlock = blocks.getBlock(this.id)
          if (!vmBlock) return

          const usedInputs = new Set(this.inputList.map(i => i?.name))

          const inputs = vmBlock.inputs
          for (const name of Object.keys(inputs)) {
            const input = inputs[name]
            if (!usedInputs.has(name)) {
              // @ts-expect-error
              blocks.deleteBlock(input.block)
              // @ts-expect-error
              blocks.deleteBlock(input.shadow)
              delete inputs[name]
            }
          }
        },

        // Gets an argument name for a prefix + index.
        getExtendableInput(prefix, index) {
          let id = prefix
          // Special handling for substacks,
          // as their names matter for execution
          if (prefix === "SUBSTACK") {
            index += 1
            if (index > 1) id += index
          } else {
            id += index
          }
          return id
        },

        // The internal create input function.
        addInput_(def, i, connectionMap = null) {
          const id = this.getExtendableInput(def.id, i)
          const input = this.appendInput_(def.type, id)
          if (def.type === ScratchBlocks.DUMMY_INPUT) {
            input.appendField(def.check)
          } else {
            if (def.check) {
              input.setCheck(def.check)
            }
            this.populateArgument_(connectionMap, id, input, def)
          }
        },

        // The "user create input" function.
        insertInput() {
          ScratchBlocks.Events.setGroup(true)
          const oldMutation = ScratchBlocks.Xml.domToText(this.mutationToDom())
          this.inputCount++

          this.updateDisplay_()

          // i have no idea if this is the correct way or not
          const newMutation = ScratchBlocks.Xml.domToText(this.mutationToDom())
          const ev = new ScratchBlocks.Events.BlockChange(
            this,
            "mutation",
            null,
            oldMutation,
            newMutation
          )
          ScratchBlocks.Events.fire(ev)
          ScratchBlocks.Events.setGroup(false)
        },
        // The "user delete input" function.
        deleteInput() {
          ScratchBlocks.Events.setGroup(true)
          const oldMutation = ScratchBlocks.Xml.domToText(this.mutationToDom())
          this.inputCount--
          const plusInputs = this.extendableDefsStart.length > 0 ? 1 : 0

          for (const def of this.extendableDefs) {
            this.removeInput(
              this.getExtendableInput(def.id, this.inputCount + plusInputs)
            )
          }
          this.updateDisplay_()

          const newMutation = ScratchBlocks.Xml.domToText(this.mutationToDom())
          const ev = new ScratchBlocks.Events.BlockChange(
            this,
            "mutation",
            null,
            oldMutation,
            newMutation
          )
          ScratchBlocks.Events.fire(ev)
          ScratchBlocks.Events.setGroup(false)

          this.cleanInputs()
        },

        createAllInputs_(connectionMap) {
          let index = 0
          if (this.extendableDefsStart.length > 0) {
            for (const def of this.extendableDefsStart)
              this.addInput_(def, index, connectionMap)
            index++
          }
          for (let i = 0; i < this.inputCount; i++) {
            for (const def of this.extendableDefs)
              this.addInput_(def, index, connectionMap)
            index++
          }
          return index
        },

        addArrowButtons_() {
          if (this.inputCount > this.minInputs) {
            const leftInput = this.appendDummyInput("ARROW_LEFT")
            const leftArrow = new FieldImageButton(
              leftArrowIcon,
              arrowWidth,
              arrowHeight,
              function () {
                this.sourceBlock_.deleteInput()
              },
              Scratch.translate({
                default: "Remove input",
                description:
                  "Alt text for the button that removes an input on blocks"
              }),
              true,
              this.inputCount < this.maxInputs
            )
            leftInput.appendField(leftArrow)
          }
          if (this.inputCount < this.maxInputs) {
            const rightInput = this.appendDummyInput("ARROW_RIGHT")
            const rightArrow = new FieldImageButton(
              rightArrowIcon,
              arrowWidth,
              arrowHeight,
              function () {
                this.sourceBlock_.insertInput()
              },
              Scratch.translate({
                default: "Add input",
                description:
                  "Alt text for the button that adds an input on blocks"
              }),
              true,
              false
            )
            rightInput.appendField(rightArrow)
          }
        },

        // Updates this block's inputs.
        updateDisplay_(force) {
          // HACK: prevent weird stray inputs from appearing in the top left corner
          if (
            !this.isInsertionMarker() &&
            !force &&
            this.workspace?.currentGesture_?.isDraggingBlock_ &&
            this.workspace?.currentGesture_?.targetBlock_.type === this.type
          )
            return

          const wasRendered = this.rendered
          if (this.isInFlyout) {
            ScratchBlocks.Events.disable()
          }

          this.rendered = false
          this.extendableUpdatedDisplay = true

          // First, disconnect any old blocks and save them for later
          const connectionMap = this.disconnectOldBlocks_()
          // Remove all extendable inputs
          this.removeAllInputs_()

          // Recreate all the inputs, and if any inputs were there before, put them back in
          let index = this.createAllInputs_(connectionMap)
          this.addArrowButtons_()
          // Add the ending inputs
          for (const def of this.extendableDefsEnd)
            this.addInput_(def, index, connectionMap)
          // Delete any unused blocks
          ScratchBlocks.ScratchBlocks.ProcedureUtils.deleteShadows_.call(
            this,
            connectionMap
          )
          this.prevInputCount = this.inputCount

          this.rendered = wasRendered
          if (wasRendered) {
            this.initSvg()
            this.render()
          }

          if (this.isInFlyout) {
            ScratchBlocks.Events.enable()
          }
        }
      },
      function () {
        // An array of extendable input definitions;
        // for each click of the right arrow button,
        // all of these inputs will be added
        this.extendableDefs = []
        // Inputs to put before any extendable inputs.
        // If non-empty, also increases the maximum index by one
        this.extendableDefsStart = []
        // Inputs to put after the extendable inputs (after the arrow buttons).
        // If non-empty, also increases the maximum index by one
        this.extendableDefsEnd = []
        // The default number of inputs.
        this.inputCount = 2
        // The minimum number of inputs.
        this.minInputs = 1
        // The maximum number of inputs.
        this.maxInputs = Infinity
        // If true, clears all blockInfo labels.
        this.clearLabels = false

        // Internal.
        this.prevInputCount = this.inputCount
      }
    )

    const createInput = (
      type, // ScratchBlocks.INPUT_VALUE, NEXT_STATEMENT or DUMMY_INPUT
      id, // The argument ID (a number will be appended to this)
      check = null, // null or "Boolean" (or the label text for DUMMY_INPUTs)
      shadowType = undefined, // The type of shadow block (or falsy for none)
      shadowField = undefined, // The field to use in the shadow block
      shadowDefault = undefined // The default shadow block value
    ) => ({ type, id, check, shadowType, shadowField, shadowDefault })

    // Configuration extensions
    ScratchBlocks.Extensions.register("cst_extendable_clear", function () {
      this.clearLabels = true
    })
    ScratchBlocks.Extensions.register("cst_extendable_string", function () {
      this.extendableDefs = [
        createInput(ScratchBlocks.INPUT_VALUE, "ARG", null, "text", "TEXT", "")
      ]
      const ops = {
        [exId + "_extendLess"]: "<",
        [exId + "_extendEqual"]: "=",
        [exId + "_extendGreater"]: ">"
      }
      if (this.type in ops) {
        const op = ops[this.type]
        this.extendableDefsStart = [
          createInput(
            ScratchBlocks.INPUT_VALUE,
            "ARG",
            null,
            "text",
            "TEXT",
            ""
          )
        ]
        this.extendableDefs.unshift(
          createInput(ScratchBlocks.DUMMY_INPUT, "WORD", op)
        )
        this.inputCount = 1
      }
    })
    ScratchBlocks.Extensions.register("cst_extendable_number", function () {
      const defaultValue = [
        exId + "_extendProduct",
        exId + "_extendDivide"
      ].includes(this.type)
        ? "1"
        : "0"

      this.extendableDefs = [
        createInput(
          ScratchBlocks.INPUT_VALUE,
          "ARG",
          null,
          "math_number",
          "NUM",
          defaultValue
        )
      ]
      this.minInputs = 1

      const ops = {
        [exId + "_extendSum"]: "+",
        [exId + "_extendMinus"]: "-",
        [exId + "_extendProduct"]: "*",
        [exId + "_extendDivide"]: "/"
      }
      if (ops[this.type]) {
        this.extendableDefsStart = [
          createInput(
            ScratchBlocks.INPUT_VALUE,
            "ARG",
            null,
            "math_number",
            "NUM",
            defaultValue
          )
        ]
        this.extendableDefs.unshift(
          createInput(ScratchBlocks.DUMMY_INPUT, "WORD", ops[this.type])
        )
        this.inputCount = 1
      }
    })
    ScratchBlocks.Extensions.register("cst_extendable_boolean", function () {
      this.extendableDefs = [
        createInput(ScratchBlocks.INPUT_VALUE, "ARG", "Boolean")
      ]
      if (
        this.type === exId + "_extendAnd" ||
        this.type === exId + "_extendOr"
      ) {
        this.extendableDefsStart = [
          createInput(ScratchBlocks.INPUT_VALUE, "ARG", "Boolean")
        ]
        this.extendableDefs.unshift(
          createInput(
            ScratchBlocks.DUMMY_INPUT,
            "WORD",
            this.type === exId + "_extendAnd"
              ? Scratch.translate({
                  default: "and",
                  description:
                    'Text inserted between inputs on the extendable "and" block. Ideally should match vanilla Scratch\'s strings'
                })
              : Scratch.translate({
                  default: "or",
                  description:
                    'Text inserted between inputs on the extendable "or" block. Ideally should match vanilla Scratch\'s strings'
                })
          )
        )
        this.inputCount = 1
      }
    })
    ScratchBlocks.Extensions.register("cst_extendable_branch", function () {
      this.extendableDefs = [
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.inputCount = 1
    })
    ScratchBlocks.Extensions.register("cst_extendable_if", function () {
      this.extendableDefsStart = [
        createInput(ScratchBlocks.INPUT_VALUE, "CONDITION", "Boolean"),
        createInput(ScratchBlocks.DUMMY_INPUT, "THEN_WORD", "then"),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.extendableDefs = [
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "ELSE_WORD",
          Scratch.translate({
            default: "else if",
            description:
              "Text inserted after a C input and before a boolean input on the extendable if blocks."
          })
        ),
        createInput(ScratchBlocks.INPUT_VALUE, "CONDITION", "Boolean"),
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "THEN_WORD",
          Scratch.translate({
            default: "then",
            description:
              "Text inserted before a C input on the extendable if blocks. Ideally should match vanilla Scratch's strings"
          })
        ),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.inputCount = 0
      this.minInputs = 0
    })
    ScratchBlocks.Extensions.register("cst_extendable_if_else", function () {
      this.extendableDefsStart = [
        createInput(ScratchBlocks.INPUT_VALUE, "CONDITION", "Boolean"),
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "THEN_WORD",
          Scratch.translate({
            default: "then",
            description:
              "Text inserted before a C input on the extendable if blocks. Ideally should match vanilla Scratch's strings"
          })
        ),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null),
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "ELSE_WORD",
          Scratch.translate({
            default: "else",
            description:
              "Text inserted before the last C input on the extendable if-else block. Ideally should match vanilla Scratch's strings"
          })
        )
      ]
      this.extendableDefs = [
        createInput(ScratchBlocks.DUMMY_INPUT, "IF_WORD", "if"),
        createInput(ScratchBlocks.INPUT_VALUE, "CONDITION", "Boolean"),
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "THEN_WORD",
          Scratch.translate({
            default: "then",
            description:
              "Text inserted before a C input on the extendable if blocks. Ideally should match vanilla Scratch's strings"
          })
        ),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null),
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "ELSE_WORD",
          Scratch.translate({
            default: "else",
            description:
              "Text inserted before the last C input on the extendable if-else block. Ideally should match vanilla Scratch's strings"
          })
        )
      ]
      this.extendableDefsEnd = [
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.inputCount = 0
      this.minInputs = 0
    })
    ScratchBlocks.Extensions.register("cst_extendable_switch", function () {
      this.extendableDefs = [
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "CASE_WORD",
          Scratch.translate({
            default: "case",
            description:
              "Text inserted between C and text inputs on the extendable switch block"
          })
        ),
        createInput(
          ScratchBlocks.INPUT_VALUE,
          "CASE_VALUE",
          null,
          "text",
          "TEXT",
          ""
        ),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.extendableDefsEnd = [
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "DEFAULT_WORD",
          Scratch.translate({
            default: "default",
            description:
              "Text inserted before the last C input on the extendable switch block"
          })
        ),
        createInput(ScratchBlocks.NEXT_STATEMENT, "SUBSTACK", null)
      ]
      this.inputCount = 1
      this.minInputs = 0
    })
    ScratchBlocks.Extensions.register("cst_extendable_joinwith", function () {
      this.extendableDefs = [
        createInput(
          ScratchBlocks.INPUT_VALUE,
          "ARG",
          null,
          "text",
          "TEXT",
          "word"
        )
      ]
      this.extendableDefsEnd = [
        createInput(
          ScratchBlocks.DUMMY_INPUT,
          "WORD_WORD",
          Scratch.translate({
            default: "with",
            description:
              "Text inserted before the last input on the 'join (...) with []' block"
          })
        ),
        createInput(ScratchBlocks.INPUT_VALUE, "ARG", null, "text", "TEXT", "_")
      ]
      this.inputCount = 2
      this.minInputs = 0
    })

    // HACK: fixes the flyout, also with dynamic enable/disable addons
    const ogInitSvg = ScratchBlocks.BlockSvg.prototype.initSvg
    ScratchBlocks.BlockSvg.prototype.initSvg = function () {
      if (this.getExtendableInput && !this.extendableUpdatedDisplay) {
        this.updateDisplay_()
      }
      return ogInitSvg.call(this)
    }
  }

  // https://github.com/LilyMakesThings/extensions/blob/5b9ce572683e403933cab3b23c4a9bbb2a08ecf9/extensions/Lily/Dictionaries.js#L37C1-L45
  if (!("scaffolding" in window)) {
    Scratch.vm.on("EXTENSION_ADDED", patchSB)
    Scratch.vm.on("BLOCKSINFO_UPDATE", patchSB)
  }
  /* eslint-enable */

  // @ts-expect-error
  Scratch.extensions.register(new HamBskyAPI(Scratch.runtime))
})(Scratch)
